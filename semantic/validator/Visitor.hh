#pragma once

#include <ymir/syntax/Declaration.hh>
#include <ymir/syntax/expression/_.hh>

#include <ymir/semantic/Symbol.hh>
#include <ymir/semantic/symbol/_.hh>
#include <ymir/semantic/Generator.hh>
#include <ymir/semantic/generator/_.hh>
#include <ymir/utils/Match.hh>
#include <ymir/syntax/expression/VarDecl.hh>

#include <list>
#include <ymir/lexing/Word.hh>
#include <ymir/errors/Error.hh>
#include <ymir/errors/ListError.hh>


namespace semantic {

	namespace validator {

		/**
		 * @struct Visitor
		 * This class is the final semantic validation before code production
		 * It will traverse all the declared symbol of a given module and validated each of them
		 * This is the most complexe class of the whole compiler, and must be treated as such with a special focus an readability.
		 * This class unlike every other class is divided in multiple .cc files, to regroups close treatments inside the same sources
		 * Above method definition, there are names, the declaration of the methods under that name are located inside the file Visitor_{name}.cc
		 * Except for Debug (located inside management), and (generator api) in Visitor.cc
		 */
		class Visitor {
		public :
			
			enum VisitConstante {
				LIMIT_TEMPLATE_RECUR = 300
			};

			static int __CALL_NB_RECURS__;

			static int __TEMPLATE_NB_RECURS__;
	    
			static bool __LAST__;

			static bool __LAST_TEMPLATE__;
	    
		private :
	    
			enum ClosureState {
				NONE = 0,
				REF = 1,
				MOVE = 2
			};
	    
			/** List of referent for symbol access and insertion */
			std::list <Symbol> _referent;

			/** The list of generator produced by the search */
			std::vector <generator::Generator> _list;
	    
			/** The list of loop breaks types (when inside a loop) cf enterLoop and quitLoop */
			std::list <generator::Generator> _loopBreakTypes;

			/** The list of dollar context (when inside a dollar context) cf enterDollar and quitDollar */
			std::list <generator::Generator> _dollars;

			/** The backup of the loop break when entering a foreign */
			std::list <std::list <generator::Generator> > _loopSaved;

			std::vector <std::vector <std::set <std::string> > > _usedSyms;
	    
			std::vector <std::vector <std::map <std::string, generator::Generator> > > _symbols;

	    
			/** All the solution generated by template specialization */
			std::vector <semantic::Symbol> _templateSolutions;

			/** All the solution that failed at validation, with associated errors */
			std::vector <std::pair <semantic::Symbol, std::list <Ymir::Error::ErrorMsg> > > _errorTemplateSolutions;

			/** The current Cas context */
			std::vector <std::vector <lexing::Word> > _contextCas;

			/**
			 * The context of class validation
			 * This is used to verify that we have the right to access to protected or private content of a class
			 */
			std::vector <semantic::Symbol> _classContext;

			/** The already validated lambdas */
			std::map <std::string, generator::Generator> _lambdas;

			/** The current enclosed vars */
			std::vector <std::vector <generator::Generator> > _enclosed;

			std::vector <generator::Generator> _lockedAlias;
	    
			std::vector <lexing::Word> _lockedAliasLoc;
	    
	    
		private :

			/**
			 * Does nothing special
			 * It is private for homogeneity reason
			 * We wan't all class to be initialized the same way
			 */
			Visitor ();

		public :

			/**
			 * Create an empty visitor
			 */
			static Visitor init ();

			/**
			 * Validate a symbol
			 * Traverse all inner declaration and validate them
			 * If no errors occurs the returned list of generators are ready for code generation
			 */
			void validate (const semantic::Symbol & sym);


			/**
			 * ================================================================================
			 * ================================================================================
			 * ================================     SYMBOLS     ===============================
			 * ================================================================================
			 * ================================================================================
			 */

			/**
			 * Validate a module
			 */
			void validateModule (const semantic::Module & mod);

			/**
			 * Validate a function
			 */
			void validateFunction (const semantic::Function & func);
	    
			/**
			 * Validate a global var declaration
			 */
			void validateVarDecl (const semantic::Symbol & sym);
	    	  
			/**
			 * Validate an aka declaration (historically called an alias, TODO, change that)
			 */
			generator::Generator validateAka   (const semantic::Symbol & sym);

			/**
			 * Validate an enum declaration
			 * Unlike, function or var decl, this will not create any generator, but just check the integrity of the enum
			 * @return An EnumRef
			 */
			generator::Generator validateEnum (const semantic::Symbol & en);

			/**
			 * Validate a struct declaration
			 * unlike, function or var decl, this will not create any generator, but just check the integrity of the structure
			 * @return A StructRef
			 */
			generator::Generator validateStruct (const semantic::Symbol & str);
	    
			/**
			 * Validate a class declaration
			 * unlike function or vardel, this will not create any generator, but just check the integrity of the the class, and generate all the inner function of the class
			 * @param inModule validate the inner symbol of the class or just the prototypes?
			 * @return A ClassRef
			 */
			generator::Generator validateClass (const semantic::Symbol & cls, bool isModule = false);

			/**
			 * Make same small verif on trait
			 * This does not generate any code
			 */
			void validateTrait (const semantic::Symbol & tra);
	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * ===============================     TEMPLATES     ==============================
			 * ================================================================================
			 * ================================================================================
			 */

			/**
			 * Validate a pre solution symbol (a template solution that has not been replaced yet)
			 */
			semantic::Symbol validateTemplatePreSolution (const semantic::Symbol & sol, const generator::Generator & gen, bool validate = true);

			/**
			 * Validate a template, if the parameters are inferable without specialization
			 */
			void validateTemplateNoSpecialization (const semantic::Symbol & sol);
		
			/**
			 * Validate a module
			 */
			void validateTemplateSolution (const semantic::Symbol & sol);

			/**
			 * Validate a template solution for a method frame
			 */
			generator::Generator validateTemplateSolutionMethod (const semantic::Symbol & sol, const generator::Generator & self);

			/**
			 * Validate a template call type from a template call literal
			 */
			generator::Generator validateTypeTemplateCall (const syntax::TemplateCall & tmpCall);

			/**
			 * Validate a template checker
			 */
			generator::Generator validateTemplateChecker (const syntax::TemplateChecker & tmpChecker);

			/**
			 * Validate a template test, a template test must be executed from the context of the template
			 * @param context the context of the template definition
			 * @param expr the test of the template
			 * @return a generator (not cte, just validated)
			 */
			generator::Generator validateTemplateTest (const Symbol & context, const syntax::Expression & expr);

			/**
			 * Validate a symbol created by templateSpecialization
			 * @param ref is the reference of the template (sometimes it is a MethodTemplateRef and need to be treated like that)
			 */
			void validateTemplateSymbol (const semantic::Symbol & sym, const generator::Generator & ref);

			/**
			 * Validate a template call expression
			 */
			generator::Generator validateTemplateCall (const syntax::TemplateCall & cl);

			/**
			 * insert a new prototype
			 * @return false if the proto already exists, true otherwise
			 */
			void insertErrorTemplateSolution (const semantic::Symbol & sol, const std::list <Ymir::Error::ErrorMsg> & errors);

			/**
			 * Remove a template solution
			 */
			void removeErrorTemplateSolution (const semantic::Symbol & sol);

	    
			/**
			 * insert a new prototype
			 * @return false if the proto already exists, true otherwise
			 */
			bool insertTemplateSolution (const semantic::Symbol & sol, std::list <Ymir::Error::ErrorMsg> & errors);

			/**
			 * Remove a template solution
			 */
			void removeTemplateSolution (const semantic::Symbol & sol);

			/**
			 * Validate a template generated list of generator (it will create a tuple)
			 */
			generator::Generator validateListTemplate (const generator::TemplateSyntaxList & list);
	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * =================================     MACROS     ===============================
			 * ================================================================================
			 * ================================================================================
			 */
	    
			/**
			 * Validate the content of a macro expression, created by a MacroVisitor, invoked by a MacroCall
			 */
			generator::Generator validateMacroExpression (const semantic::Symbol & sol, const syntax::Expression & expr);

			/**
			 * Validate a macro call
			 */
			generator::Generator validateMacroCall (const syntax::MacroCall & call);

	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * =================================      TYPES     ===============================
			 * ================================================================================
			 * ================================================================================
			 */
	    
			/**
			 * validate an expression, that produce a type
			 * @return a generator containing the resulting type
			 * @param lock if the return type is not mutable do we lock the mutability ?
			 * @      if true, even if we set it to mutable later all the inner types will be immutable
			 */
			generator::Generator validateType (const syntax::Expression & type, bool lock);

			/**
			 * validate an expression, that produce a type, if it failed with validateType (so it must be a ClassRef)
			 * @return a generator containing the resulting type
			 * @param lock if the return type is not mutable do we lock the mutability ?
			 * @      if true, even if we set it to mutable later all the inner types will be immutable
			 */
			generator::Generator validateTypeClassRef (const syntax::Expression & type, bool lock);

			/**
			 * validate an expression, that produce a type
			 * @return a generator containing the resulting type
			 */
			generator::Generator validateType (const syntax::Expression & type);
	    
			/**
			 * validate an expression, that produce a type, if it failed with validateType (so it must be a ClassRef)
			 * @return a generator containing the resulting type
			 */
			generator::Generator validateTypeClassRef (const syntax::Expression & type);

			/**
			 * Validate a decorated type
			 * @param canBeClassRef, true if it can be a class ref (from a UnaryOp type creation)
			 */
			generator::Generator validateTypeDecorated (const syntax::DecoratedExpression & type, bool canBeClassRef = false);
	    
			/**
			 * Validate the var using it as a type
			 */
			generator::Generator validateTypeVar (const syntax::Var & var);

			/**
			 * Validate the unary using it as a type (for &() for example)
			 */
			generator::Generator validateTypeUnary (const syntax::Unary & var);

			/**
			 * Validate the unary using it as a type (for (i32)? for example)
			 */
			generator::Generator validateTypeTry (const syntax::Try & tr);
	    
			/**
			 * Validate an array allocation as a type
			 */
			generator::Generator validateTypeArrayAlloc (const syntax::ArrayAlloc & alloc);

			/**
			 * Validate a slice type from an array literal
			 */
			generator::Generator validateTypeSlice (const syntax::List & array);
	    
			/**
			 * Validate a tuple type from a tuple literal
			 */
			generator::Generator validateTypeTuple (const syntax::List & tuple);

			/**
			 * Validate a tuple type from a template syntax list
			 */
			generator::Generator validateTypeTupleTemplate (const generator::TemplateSyntaxList & tuple);

			/**
			 * @return the typeinfo of the type type
			 */
			generator::Generator validateTypeInfo (const lexing::Word & loc, const generator::Generator & type);

			/**
			 * @return the name of the field in TypeIDs for the type type
			 */
			static std::string typeInfoName (const generator::Generator & type);

			/**
			 * Validate a func ptr type (fn or dg) into generate type
			 */
			generator::Generator validateFuncPtr (const syntax::FuncPtr & ptr);

			/**
			 * Validate a type from a class context
			 */
			generator::Generator validateTypeClassContext (const lexing::Word & loc, const generator::Generator & cl, const syntax::Expression & type);

	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * ==============================      STATEMENTS     =============================
			 * ================================================================================
			 * ================================================================================
			 */
	    
	    
			/**
			 * Validate a throw expression
			 */
			generator::Generator validateThrow (const syntax::Throw & thr);

			/**
			 * Validate a match expression
			 */
			generator::Generator validateMatch (const syntax::Match & matcher);

			/**
			 * Validate an assert
			 */
			generator::Generator validateAssert (const syntax::Assert & assert);

			/**
			 * Validate an assert at compile time,
			 */
			generator::Generator validateCteAssert (const syntax::Assert & assert);
	    

			/**
			 * Validate a pragma
			 */
			generator::Generator validatePragma (const syntax::Pragma & prg);

			/**
			 * Validate a with expression
			 */
			generator::Generator validateWith (const syntax::With & wh);

			/**
			 * Validate an atomic expression
			 */
			generator::Generator validateAtomic (const syntax::Atomic & atom);

			/**
			 * Validate an if expression
			 * @return as always a generator
			 * @warning the generator is not always a if expression, for optimization purpose (such as the test is always false, ...)
			 */
			generator::Generator validateIfExpression (const syntax::If & _if);

			/**
			 * Validate an if expression and evaluate it at compile time
			 * @return as always a generator
			 */
			generator::Generator validateCteIfExpression (const syntax::If & _if);
	    
			/**
			 * Validate a while expression
			 * @return as always a generator
			 */
			generator::Generator validateWhileExpression (const syntax::While & _wh);

			/**
			 * Validate a for expression
			 * @return as always a generator
			 */
			generator::Generator validateForExpression (const syntax::For & _for, bool isCte = false);
	    
			/**
			 * Validate a break expression
			 */
			generator::Generator validateBreak (const syntax::Break & br);

			/**
			 * Validate a return expression
			 */
			generator::Generator validateReturn (const syntax::Return & rt);

			/**
			 * Validate a cast expression
			 */
			generator::Generator validateCast (const syntax::Cast & cast);
	    
			/**
			 * Validate a destruct declaration
			 */
			generator::Generator validateDestructDecl (const syntax::DestructDecl & decl);

			/**
			 * Validate a var declaration inside a block (or a frame)
			 * @param needValue Is the value mandatory in this var declaration?
			 */
			generator::Generator validateVarDeclValue (const syntax::VarDecl & decl, bool needValue = true);

			/**
			 * Validate a try expression
			 */
			generator::Generator validateTry (const syntax::Try & tr);

			/**
			 * ================================================================================
			 * ================================================================================
			 * ===============================     INTRINSICS    ==============================
			 * ================================================================================
			 * ================================================================================
			 */
	    
			/**
			 * Validate intricisics, it could be either :
			 * - a copy
			 * - an expand
			 * - type informations ...
			 */
			generator::Generator validateIntrinsics (const syntax::Intrinsics & intr);
	    	    
			/**
			 * Validate the copy intrinsics
			 */
			generator::Generator validateCopy (const syntax::Intrinsics & intr);

			/**
			 * Validate the deep copy intrinsics
			 */
			generator::Generator validateDeepCopy (const syntax::Intrinsics & intr);

			/**
			 * Validate the alias intrinsics
			 */
			generator::Generator validateAlias (const syntax::Intrinsics & intr);

			/**
			 * Validate the expand intrinsics
			 */
			generator::Generator validateExpand (const syntax::Intrinsics & intr);

	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * ===============================      LITERALS     ==============================
			 * ================================================================================
			 * ================================================================================
			 */
	    	    
	    
			/**
			 * Validate a dollar expression
			 */
			generator::Generator validateDollar (const syntax::Dollar & dl);

	    
			/**
			 * Validate an fixed const integer value
			 */
			generator::Generator validateFixed (const syntax::Fixed & fixed, int base = 0);
	    
			/**
			 * Validate a const bool value
			 */
			generator::Generator validateBool (const syntax::Bool & b);

			/**
			 * Validate a const floating value
			 */
			generator::Generator validateFloat (const syntax::Float & f);

			/**
			 * Validate a literal char
			 */
			generator::Generator validateChar (const syntax::Char & c);

			/**
			 * Validate a string literal
			 */
			generator::Generator validateString (const syntax::String & s, bool forceUtf8 = false);
	    	    
			/**
			 * Validate a list, it could be either :
			 * - an array
			 * - a tuple
			 * - an array type
			 * - a tuple type
			 */
			generator::Generator validateList (const syntax::List & list);

			/**
			 * Validate an array alloc
			 */
			generator::Generator validateArrayAlloc (const syntax::ArrayAlloc & alloc);

			/**
			 * Validate a lambda function
			 */
			generator::Generator validateLambda (const syntax::Lambda & lmbd);

			/**
			 * Validate a lambda proto that is validated by calling it
			 */
			generator::Generator validateLambdaProto (const generator::LambdaProto & lmbd, const std::vector <generator::Generator> & types);

			/**
			 * Create the closure value, that will be passed in the delegate value
			 * A closure value is a copy or a ref to all the enclosed variable in a tuple value that is then copied to heap
			 */
			generator::Generator validateClosureValue (const generator::Generator & closureType, bool isrefClosure, uint closureIndex);

			/**
			 * Validate a null value
			 */
			generator::Generator validateNullValue (const syntax::Null & nl);

			/**
			 * validate an array literal
			 */
			generator::Generator validateArray (const syntax::List & list);

			/**
			 * validate an tuple literal
			 */
			generator::Generator validateTuple (const syntax::List & list);
	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * =================================      BLOCKS     ==============================
			 * ================================================================================
			 * ================================================================================
			 */
	    	    
	    
			/**
			 * Validate a scope guard (this function must be called only if this scope is out from any scope)
			 * @param sc the scope guard to validate
			 */
			generator::Generator validateScopeOutOfScope (const syntax::Scope & sc);


			/**
			 * Validate a catch (this function must be called only if this catch is out from any scope)
			 * @param cat the catcher to validate
			 */
			generator::Generator validateCatchOutOfScope (const syntax::Catch & cat);
	    
			/**
			 * Validate a block of expression
			 * @return a tree containing the result of the block
			 */
			generator::Generator validateBlock (const syntax::Block & block, const std::vector <generator::Generator> & init = {});

			/**
			 * Validate the content of a block (the values)
			 * @returns:
			 *    - values: the list of values inside the block
			 *    - type: the type of the block
			 *    - valueLoc: the location of the last value giving the type of the block
			 *    - returner: the content of the block necessarily return at some point
			 *    - rtLoc: the location of the returner
			 *    - breaker: the content of the block necessarily breaks
			 *    - brLoc: the location of the breaker
			 */
			void validateInnerBlock (const syntax::Block & block, std::vector <generator::Generator> & values, generator::Generator & type, lexing::Word & valueLoc, bool & returner, lexing::Word & rtLoc, bool & breaker, lexing::Word& brLoc, std::list <Ymir::Error::ErrorMsg> & errors);

			/**
			 * Validate a catch block
			 * return by ref the vardecls and actions to perform in case of catch
			 * All the actions must return the type type (if type !is void)
			 * The type of the block may change, in case of common ancestor
			 */
			void validateCatcher (const syntax::Block & block, generator::Generator & varDecl, generator::Generator & typeInfos, generator::Generator & actions, generator::Generator& type, const std::vector <generator::Generator> & throwsTypes, std::list <Ymir::Error::ErrorMsg> & errors);

			/**
			 * Validate the scope parts of a block (exit, failure and success)
			 */
			void validateScopes (const syntax::Block & block, std::vector <generator::Generator> & onExit, std::vector <generator::Generator> & onSuccess, std::vector <generator::Generator> & onFailure, bool & returner, bool & breaker, bool hasThrowers, std::list <Ymir::Error::ErrorMsg> & errors);
	    
			/**
			 * Validate an inner declaration of a module
			 * @param decl the module to declare, and validate
			 */
			semantic::Symbol validateInnerModule (const syntax::Declaration & decl, std::list <Ymir::Error::ErrorMsg> & errors);

			/**
			 * Validate a set of expression
			 * @return a tree containing the result of the block
			 */
			generator::Generator validateSet (const syntax::Set & set);
	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * =================================      VALUES     ==============================
			 * ================================================================================
			 * ================================================================================
			 */
	    	    
	    
			/**
			 * Validate a value, and ensure that it has a type and not a void type
			 * @return a tree containing the value
			 */
			generator::Generator validateValueNonVoid (const syntax::Expression & expr);
	    
			/**
			 * validate an expression, that produce a value
			 * If the value is a breaker or a returner throw an error
			 * @return a tree containing the result of the value
			 */
			generator::Generator validateValue (const syntax::Expression & value, bool canBeType = false, bool fromCall = false, bool checkReach = false, bool fromValidateType = false);

			/**
			 * Validate an compile time expression , that produce a value
			 * If the value is a breaker or a returner throw an error
			 * @return a tree containing the result of the value
			 */
			generator::Generator validateCteValue (const syntax::Expression & value);
	    
			/**
			 * validate an expression, that produce a value
			 * @return a tree containing the result of the value
			 */
			generator::Generator validateValueNoReachable (const syntax::Expression & value, bool fromCall = false);

	    	    	    	    
			/**
			 * execute the content of the generator in order to retreive the compile time value
			 */
			generator::Generator retreiveValue (const generator::Generator & gen);


			/**
			 * ================================================================================
			 * ================================================================================
			 * =================================    OPERATORS    ==============================
			 * ================================================================================
			 * ================================================================================
			 */
	   	   	    	    	    
			/**
			 * Validate a binary expression
			 * This generation is a bit complex as it depends on the type of the operands
			 * All binary operations are handled by BinaryVisitor class
			 */
			generator::Generator validateBinary (const syntax::Binary & bin, bool isFromCall = false);

			/**
			 * Validate a unary expression
			 * All unary operations are handled by UnaryVisitor class
			 */
			generator::Generator validateUnary (const syntax::Unary & un);

			/**
			 * Validate a mult operator
			 * A mult operator is an operator with one left operand and multiple right operand
			 * It can be either :
			 * - Brackets
			 * - Parentheses
			 */
			generator::Generator validateMultOperator (const syntax::MultOperator & mult);
	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * ===============================    VARS AND REFS    ============================
			 * ================================================================================
			 * ================================================================================
			 */
	   	   	    	    	    
			/**
			 * Validate a var
			 * It will check all the local reference
			 * If no local reference are found, it will find the symbol inside the table of the current frame
			 * And then produce the generator for this symbol
			 */
			generator::Generator validateVar (const syntax::Var & var);

			/**
			 * Transform global extern symbol into valid generators
			 * @param loc the location of the reference to those symbols
			 * @param multSym the list of symbols
			 * @param fromTemplate allow from template frame prototype
			 */
			generator::Generator validateMultSym (const lexing::Word & loc, const std::vector <Symbol> & multSym);

			/**
			 * Transform global extern symbol into valid generators
			 * @param loc the location of the reference to those symbols
			 * @param multSym the list of symbols
			 */
			generator::Generator validateMultSymType (const lexing::Word & loc, const std::vector <Symbol> & multSym);
	    	    
			/**
			 * Validate a decorated expression
			 */
			generator::Generator validateDecoratedExpression (const syntax::DecoratedExpression & dec_expr);

			/**
			 * Validate a mult sym proto,
			 */
			generator::Generator validateMultSymProto (const generator::Generator & sym, const std::vector <generator::Generator> & types);
	    

			/**
			 * ================================================================================
			 * ================================================================================
			 * ================================   VERIFICATIONS  ==============================
			 * ================================================================================
			 * ================================================================================
			 */
	    	    	  	    

			/**
			 * this function is called each time a copy is performed
			 * @param loc the location of the affectation
			 * @param type the type result of the copy
			 * @param gen the generator that will produce the affectation
			 * @param construct is this a construction ? (ref are not affected yet)
			 * This function verify that the mutability of gen is preserved
			 * And that no implicit operation are performed
			 */
			void verifyMemoryOwner (const lexing::Word & loc, const generator::Generator & type, const generator::Generator & gen, bool construct, bool checkTypes = true, bool inMatch = false);


			/**
			 * Verify the level of mutability of the left and right type (left <- right)
			 */
			void verifyMutabilityLevel (const lexing::Word & loc, const lexing::Word & rloc, const generator::Generator & leftType, const generator::Generator & rightType, bool construct);
	    
			/**
			 * Verify that if the type must be copied or aliased, the generator gives an explicitly alias construction
			 */
			void verifyImplicitAlias (const lexing::Word & loc, const generator::Generator & type, const generator::Generator & gen);

			/**
			 * Verify that the type is complete and can be used at runtime to store value
			 */
			void verifyCompleteType (const lexing::Word & loc, const generator::Generator & type);

			/**
			 * Verify that a parameter (of a function, or a for loop or ...) is mutable iif it is a reference
			 * There is some exception, you must call this function to verify the correct behavior
			 * @param loc the location of the variable declaration
			 * @param type the type of the var
			 * @param error the error to throw, (in case of error)
			 */
			void verifyMutabilityRefParam (const lexing::Word & loc, const generator::Generator & type, Ymir::ExternalErrorValue error);

			/**
			 * Throw an exception if left.equals (right) is false
			 * @param left a type
			 * @param rigth a type
			 */
			void verifySameType (const generator::Generator & left, const generator::Generator & right);

			/**
			 * Throw an exception if left.equals (right) is false
			 * @param left a type
			 * @param rigth a type
			 */
			void verifyCompleteSameType (const generator::Generator & left, const generator::Generator & right);
	    
			/**
			 * Verify that the class cl implement the trait tr
			 */
			void verifyClassImpl (const lexing::Word & loc, const generator::Generator & cl, const syntax::Expression & tr);

			/**
			 * Verify that the class cl implement the trait tr
			 */
			void verifyClassImpl (const lexing::Word & loc, const generator::Generator & cl, const generator::Generator & tr);

			/**
			 * Throw an exception if left.isCompatible (right) is false
			 * @param left a type
			 * @param right a type
			 * @param fromObject, if the left type is an &core::object::Object, and right is a ClassPtr, then the type is compatible iif fromObject
			 */
			void verifyCompatibleType (const lexing::Word & loc, const lexing::Word & rightLoc, const generator::Generator & left, const generator::Generator & right, bool fromObject = false);

	    
			/**
			 * Throw an exception if left.isCompatible (right.getType ()) is false
			 * @param left a type
			 * @param right a value
			 */
			void verifyCompatibleTypeWithValue (const lexing::Word & loc, const generator::Generator & left, const generator::Generator & right);


			/**
			 * Throw an exception if there is already some var named name
			 * @param name the forbidden name
			 */
			void verifyShadow (const lexing::Word & name);

			/**
			 * Throw an exception if name refer to a primitive type
			 * @param the possibly forbidden name
			 */
			void verifyNotIsType (const lexing::Word & name);

			/**
			 * Verify that a given value is not locked for aliasing
			 */
			void verifyLockAlias (const generator::Generator & gen);
	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * =================================      TESTS     ===============================
			 * ================================================================================
			 * ================================================================================
			 */
	    	    	  
	    
			/**
			 * @return true, if we can make an implicit alias of the value
			 */
			bool canImplicitAlias (const generator::Generator & value);

			/**
			 * Is the type a void array
			 */
			bool isVoidArrayType (const generator::Generator & type);

			/**
			 * @return true if left is a classRef that is an ancestor of right also a classref
			 */
			bool isAncestor (const generator::Generator & left, const generator::Generator & right);
	    
			/**
			 * Is the value known at compile time and is a fixed constant
			 */
			bool isIntConstant (const generator::Generator & val);

			/**
			 * Is the value known at compile time and is a float const
			 */
			bool isFloatConstant (const generator::Generator & val);

	    
			/**
			 * Tell if an expression use alone has any effect, or if it is just a lost of computation power
			 * @param gen the expression to test
			 */
			bool isUseless (const generator::Generator & gen);


			/**
			 * ================================================================================
			 * ================================================================================
			 * ===================================   GETTERS  =================================
			 * ================================================================================
			 * ================================================================================
			 */
	    
			/**
			 * Applicable to the type of a vardecl,
			 * @param decos the decorators of the variable (and not of the type)
			 * @param type the type of the var declaration
			 * @return isRef ref decorator found
			 * @return isMutable mut decorator found
			 */
			generator::Generator applyDecoratorOnVarDeclType (const std::vector <syntax::DecoratorWord> & decos, const generator::Generator & type, bool & isRef, bool & isMutable, bool & dmut, bool canBeRef = true, bool canBeMut = true, bool canBeDmut = true);

	    
			/**
			 * @return the list of all implemented traits in the class cl
			 */
			std::vector <generator::Generator> getAllImplClass (const generator::Generator & cl);

			/**
			 * Get the current context for class access
			 * @param cl a class symbol that we want to access
			 * @param isPrivate return by ref, will be true if we have the right to access to private elements of cl
			 * @param isProtected return by ref, will be true if we have the right to access to protected elements of cl
			 * @info as public is always true, it is not a parameter here
			 */
			void getClassContext (const semantic::Symbol & cl, bool & isPrivate, bool & isProtected);

			/**
			 * Get the current context for a macro access
			 */
			void getMacroContext (const semantic::Symbol & cl, bool & isPrivate);

			/**
			 * @return the list of (in a multsym) of the constructor of the class cl
			 * @warning cl is assumed to be a generator::Class
			 */
			generator::Generator getClassConstructors (const lexing::Word & loc, const generator::Generator & cl, const lexing::Word & name);

			/**
			 * @return the list of constructor of the macro
			 */
			std::vector <semantic::Symbol> getMacroConstructor (const lexing::Word & loc, const generator::MacroRef & mref);

			/**
			 * @return the list of macro rule of the macro
			 * @param name the name of the rule
			 */
			std::vector <semantic::Symbol> getMacroRules (const lexing::Word & loc, const generator::MacroRef & ref, const std::string & name);

			/**
			 * @return the list of macro rules of the current macro context
			 * @param name the name of the rule
			 */
			semantic::Symbol getCurrentMacroRules (const lexing::Word & loc, const std::string & name);
	    
			/**
			 * @return the list of constructors declared in the class
			 */
			std::vector <syntax::Declaration> getAllConstructors (const std::vector <syntax::Declaration> & innerClass, const lexing::Word & name);
	    
			/**
			 * Get the current context of the current state
			 * If mod is an ancestor of the current ref, return will be true
			 * It means that all the private declaration of mod can be accessed in the current state
			 */
			bool  getModuleContext (const semantic::Symbol & mod);

	    	    
			/**
			 * @returns: the common ancestor from two class refs (or classptrs)
			 */
			generator::Generator getCommonAncestor (const generator::Generator & left, const generator::Generator & right);

			/**
			 * ================================================================================
			 * ================================================================================
			 * ===============================     INFERENCES    ==============================
			 * ================================================================================
			 * ================================================================================
			 */


			/**
			 * Deduce the type that can be used as a common ancestor type for left and right
			 * Might no throw anything even if left and right are incompatible, must verify the compatibility afterwards, between type, left and right
			 */
			generator::Generator inferTypeBranching (const lexing::Word & lloc, const lexing::Word & rloc, const generator::Generator & left, const generator::Generator & right);


			/**
			 * ================================================================================
			 * ================================================================================
			 * ================================       ERRORS     ==============================
			 * ================================================================================
			 * ================================================================================
			 */
	    
			/**
			 * @throw the error saying that left and right are incompatible types
			 */
			void throwIncompatibleTypes (const lexing::Word & loc, const lexing::Word & rightLoc, const generator::Generator & left, const generator::Generator & right, const std::list <Ymir::Error::ErrorMsg> & notes);


			/**
			 * ================================================================================
			 * ================================================================================
			 * =============================   SCOPE MANAGEMENT  ==============================
			 * ================================================================================
			 * ================================================================================
			 */

	    
			/**
			 * Enter a foreign definition
			 * all the symbol currently declared in local block won't be accessible until we exit the foreign
			 */
			void enterForeign ();

			/**
			 * exit the foreign (Cf. enterForeign)
			 */
			void exitForeign ();
	    
			/**
			 * Enter a new closure
			 */
			void enterClosure (bool isRefClosure, uint refId, uint index);

			/**
			 * Quit a closure
			 * @returns all the enclosed vars
			 */
			generator::Generator exitClosure ();
	    
			/**
			 * enter a new context,
			 * A context is a list of Cas (only used in a function)
			 * This list define the behavior that are not allowed
			 */
			void enterContext (const std::vector <lexing::Word> & Cas);

			/**
			 * Exit the context (Cf. enterContext)
			 */
			void exitContext ();

			/**
			 * enter a new class context
			 */
			void enterClassDef (const semantic::Symbol & sym);


			/**
			 * Exit a class context (Cf. enterClassDef)
			 */
			void exitClassDef (const semantic::Symbol & sym);

	    	    
	    
			/**
			 * @return does the current context include context
			 */
			bool isInContext (const std::string & context);

			/**
			 * Tell if the current context allows trusted declarations
			 */
			bool isInTrusted () const;

	    
			/**
			 * Enter a new scope
			 */
			void enterBlock ();

			/**
			 * Lock the possibility of alias the content of gen for a moment
			 */
			void lockAliasing (const lexing::Word & loc, const generator::Generator & gen);

			/**
			 * Unlock the possibility of alias the content of gen
			 */
			void unlockAliasing (const generator::Generator & gen);
	    
			/**
			 * Exit a scope
			 */
			void quitBlock ();

			/**
			 * Exit the scope, but return the errors inside errors,
			 */
			void quitBlock (std::list <Ymir::Error::ErrorMsg> & errors);
	    
			/**
			 * Ignore all the local var declared in the current block
			 * @return all the local var discarded
			 */
			std::map <std::string, generator::Generator> discardAllLocals ();
	    
			/**
			 * Enter a new breakable loop
			 */
			void enterLoop ();
	    
			/**
			 * quit a breakable loop
			 * @return the type of the inner breakers
			 */
			generator::Generator quitLoop ();

			/**
			 * Enter a new dollar context
			 */
			void enterDollar (const generator::Generator & gen);

			/**
			 * Quit a dollar context
			 */
			void quitDollar ();


			/**
			 * @return the loop type
			 */
			const generator::Generator & getCurrentLoopType () const;

			/**
			 * Change the type of the current loop
			 */
			void setCurrentLoopType (const generator::Generator & type);

			/**
			 * Return the type of the current fn
			 */
			generator::Generator getCurrentFuncType () ;

			/**
			 * Set the type of the current fn
			 */
			void setCurrentFuncType (const generator::Generator & type);
	    
			/**
			 * @return !this-> _loopBreakTypes.empty ()
			 */
			bool isInLoop () const;

			/**
			 * @return true if we are validating a closure
			 */
			bool isInClosure ();

			/**
			 * @return true if we are validating a closure and it is a ref one
			 */
			bool isInRefClosure ();

			/**
			 * Get a variable in the encosed element
			 */
			generator::Generator getInClosure (const std::string & name);
	    
			/**
			 * insert a new symbol in the frame local scope
			 * @param name the name of the symbol
			 * @param local the symbol
			 */
			void insertLocal (const std::string & name, const generator::Generator & local);
	    
			/**
			 * Get a localy declared symbol
			 * @param name the name of the symbol to get
			 */
			generator::Generator getLocal (const std::string & name, bool canBeInClosure = true) ;


			/**
			 * Retreive a globally declared symbol (outside of the frame, or inner declared but not local just private)
			 * @param name the name of the symbol to retreive
			 */
			std::vector <Symbol> getGlobal (const std::string & name);


			/**
			 * Retreive a globally declared symbol (outside of the frame, or inner declared but not local just private)
			 * @param name the name of the symbol to retreive
			 */
			std::vector <Symbol> getGlobalPrivate (const std::string & name);

			/**
			 * this-> _referent.push_back (sym)
			 */
			void pushReferent (const semantic::Symbol & sym, const std::string & msg);

			/**
			 * this-> _referent.pop_back ()
			 */
			void popReferent (const std::string & msg);

			/**
			 * ================================================================================
			 * ================================================================================
			 * ==============================        UTILS        =============================
			 * ================================================================================
			 * ================================================================================
			 */

			/**
			 * Create an expression, that evaluated will have a value pointing to the var at a given path
			 * This function can be used to easily refers to variable defined in core files for example
			 * Such a getting the Object class, by creating the var {"core", "object", "Object"}.
			 */
			syntax::Expression createVarFromPath (const lexing::Word & loc, const std::vector <std::string> & path);

			/**
			 * Does approximately the same as createVarFromPath, but add an unary expression around tha var to create a ClassPtr once evaluated.
			 * For example, this function can be used to get an excpetion defined in a core file
			 */
			syntax::Expression createClassTypeFromPath (const lexing::Word & loc, const std::vector <std::string> & path);

			/**
			 * Append a else to a conditional (recursively)
			 * This will appen an else statement at the end of a list of conditional, for example, with the following conditional:
			 * ===================
			 * (if (test1) { value1 } else if (test2) { value2 }).addElseToConditional ({value3}), =>
			 *     (if (test1) { value1 } else if (test2) { value2 } else { value3 }
			 * ===================
			 * The value added can obviousely be a if conditional
			 */
			generator::Generator addElseToConditional (const generator::Generator & cond, const generator::Generator & _else);

			/**
			 * Transform a conditional to a complete conditional (meaning we assure that all the test covers every cases, and thus we enter a branch no matter what)
			 * This doesn't add anything to the conditional, but is used to remove some errors in the compiler, such as incompatible types with void as there is no final else
			 * This function can be used when we can ensure the every if condition covers every cases, for example in a pattern matching (or a catcher)
			 */
			generator::Generator setCompleteConditional (const generator::Generator &cond);


	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * =============================  GENERATION INTERFACE  ===========================
			 * ================================================================================
			 * ================================================================================
			 */
	    	    	  	    
			/**
			 * @return the list of generator produced by semantic validation
			 */
			const std::vector <generator::Generator> & getGenerators () const;	    

			/**
			 * Insert a new Generator that has passed the semantic validation
			 * All the symbol passed here, will be transformed at generation time
			 * @param generator the valid generator
			 */
			void insertNewGenerator (const generator::Generator & generator);


			/**
			 * Try to retreive the frame from the prototype
			 * Basically a by name search
			 * @warning can return an empty generator, if the frame was not found
			 */
			const generator::Generator & retreiveFrameFromProto (const generator::FrameProto & proto);
	    
			/**
			 * ================================================================================
			 * ================================================================================
			 * =============================         DEBUG          ===========================
			 * ================================================================================
			 * ================================================================================
			 */
	    
			/**
			 * Print the variable in the local scopes, for debugging purposes
			 */
			void printLocal () const;
	    
		};
	       
	}
    
}
