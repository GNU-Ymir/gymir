#pragma once

#include <ymir/syntax/Declaration.hh>
#include <ymir/syntax/expression/_.hh>

#include <ymir/semantic/Symbol.hh>
#include <ymir/semantic/symbol/_.hh>
#include <ymir/semantic/Generator.hh>
#include <ymir/semantic/generator/_.hh>
#include <ymir/utils/Match.hh>
#include <ymir/syntax/expression/VarDecl.hh>

#include <list>
#include <ymir/lexing/Word.hh>
#include <ymir/errors/Error.hh>
#include <ymir/errors/ListError.hh>


namespace semantic {

    namespace validator {

	class Visitor;
	
	struct VisitorCache {
	    Ymir::Lazy <generator::Generator, Visitor> typeInfo;	    
	    Ymir::Lazy <generator::Generator, Visitor> typeIds;
	    Ymir::Lazy <generator::Generator, Visitor> disposeTrait;
	    Ymir::Lazy <generator::Generator, Visitor> exceptionType;
	    Ymir::Lazy <generator::Generator, Visitor> objectType;
	    Ymir::Lazy <generator::Generator, Visitor> segFault;

	    VisitorCache (Visitor & context);	    
	};
	
	
	/**
	 * @struct Visitor
	 * This class is the final semantic validation before code production
	 * It will traverse all the declared symbol of a given module and validated each of them
	 * This is the most complexe class of the whole compiler, and must be treated as such with a special focus an readability.
	 * This class unlike every other class is divided in multiple .cc files, to regroups close treatments inside the same sources
	 * Above method definition, there are names, the declaration of the methods under that name are located inside the file Visitor_{name}.cc
	 * Except for Debug (located inside management), and (generator api) in Visitor.cc
	 */
	class Visitor {
	public :
			
	    enum VisitConstante {
		LIMIT_TEMPLATE_RECUR = 300
	    };

	    static int __CALL_NB_RECURS__;

	    static int __TEMPLATE_NB_RECURS__;
	    
	    static bool __LAST__;

	    static bool __LAST_TEMPLATE__;
	    
	private :
	    
	    enum ClosureState {
		NONE = 0,
		REF = 1,
		MOVE = 2
	    };
	    
	    /** List of referent for symbol access and insertion */
	    std::list <Symbol> _referent;

	    /** The list of generator produced by the search */
	    std::vector <generator::Generator> _list;
	    
	    /** The list of loop breaks types (when inside a loop) cf enterLoop and quitLoop */
	    std::list <generator::Generator> _loopBreakTypes;

	    /** The list of dollar context (when inside a dollar context) cf enterDollar and quitDollar */
	    std::list <generator::Generator> _dollars;

	    /** The backup of the loop break when entering a foreign */
	    std::list <std::list <generator::Generator> > _loopSaved;

	    std::vector <std::vector <std::set <std::string> > > _usedSyms;
	    
	    std::vector <std::vector <std::map <std::string, generator::Generator> > > _symbols;

	    
	    /** All the solution generated by template specialization */
	    std::vector <semantic::Symbol> _templateSolutions;

	    /** All the solution that failed at validation, with associated errors */
	    std::vector <std::pair <semantic::Symbol, std::list <Ymir::Error::ErrorMsg> > > _errorTemplateSolutions;

	    /** The current Cas context */
	    std::vector <std::vector <lexing::Word> > _contextCas;

	    /**
	     * The context of class validation
	     * This is used to verify that we have the right to access to protected or private content of a class
	     */
	    std::vector <semantic::Symbol> _classContext;

	    /** The already validated lambdas */
	    std::map <std::string, generator::Generator> _lambdas;

	    /** The current enclosed vars */
	    std::vector <std::vector <generator::Generator> > _enclosed;

	    std::vector <generator::Generator> _lockedAlias;
	    
	    std::vector <lexing::Word> _lockedAliasLoc;

	    /** The list of class symbol we need to validate */
	    std::vector <Symbol> _classToValidate;

	    VisitorCache _cache;
	    
	private :

	    /**
	     * Does nothing special
	     * It is private for homogeneity reason
	     * We wan't all class to be initialized the same way
	     */
	    Visitor ();

	public :

	    /**
	     * Create an empty visitor
	     */
	    static Visitor init ();

	    /**
	     * Validate a symbol
	     * Traverse all inner declaration and validate them
	     * If no errors occurs the returned list of generators are ready for code generation
	     */
	    void validate (const semantic::Symbol & sym, bool inModule = true);

	    /**
	     * To run after the validation of the global module
	     * This function validate all the inner symbols of the locally declared classes
	     */
	    void validateAllClasses ();

	    /**
	     * ================================================================================
	     * ================================================================================
	     * ================================     SYMBOLS     ===============================
	     * ================================================================================
	     * ================================================================================
	     */

	    /**
	     * Validate a module
	     */
	    void validateModule (const semantic::Module & mod);

	    /**
	     * Validate a function
	     */
	    void validateFunction (const semantic::Function & func);
	    
	    /**
	     * Validate a global var declaration
	     */
	    void validateVarDecl (const semantic::Symbol & sym, bool inModule);
	    	  
	    /**
	     * Validate an aka declaration (historically called an alias, TODO, change that)
	     */
	    generator::Generator validateAka   (const semantic::Symbol & sym);

	    /**
	     * Validate an enum declaration
	     * Unlike, function or var decl, this will not create any generator, but just check the integrity of the enum
	     * @return An EnumRef
	     */
	    generator::Generator validateEnum (const semantic::Symbol & en);

	    /**
	     * Validate a struct declaration
	     * unlike, function or var decl, this will not create any generator, but just check the integrity of the structure
	     * @return A StructRef
	     */
	    generator::Generator validateStruct (const semantic::Symbol & str);
	    
	    /**
	     * Validate a class declaration
	     * unlike function or vardel, this will not create any generator, but just check the integrity of the the class, and generate all the inner function of the class
	     * @param inModule validate the inner symbol of the class or just the prototypes?
	     * @return A ClassRef
	     */
	    generator::Generator validateClass (const semantic::Symbol & cls, bool isModule = false);

	    /**
	     * Make same small verif on trait
	     * This does not generate any code
	     */
	    void validateTrait (const semantic::Symbol & tra);
	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * ===============================     TEMPLATES     ==============================
	     * ================================================================================
	     * ================================================================================
	     */

	    /**
	     * Validate a pre solution symbol (a template solution that has not been replaced yet)
	     */
	    semantic::Symbol validateTemplatePreSolution (const semantic::Symbol & sol, const generator::Generator & gen, bool validate = true, bool inModule = false, bool isWeak = true);

	    /**
	     * Validate a template, if the parameters are inferable without specialization
	     */
	    void validateTemplateNoSpecialization (const semantic::Symbol & sol);
		
	    /**
	     * Validate a module
	     */
	    void validateTemplateSolution (const semantic::Symbol & sol, bool inModule);

	    /**
	     * Validate a template solution for a method frame
	     */
	    generator::Generator validateTemplateSolutionMethod (const semantic::Symbol & sol, const generator::Generator & self);


	    /**
	     * Validate a template checker
	     */
	    generator::Generator validateTemplateChecker (const syntax::TemplateChecker & tmpChecker);

	    /**
	     * Validate a template test, a template test must be executed from the context of the template
	     * @param context the context of the template definition
	     * @param expr the test of the template
	     * @return a generator (not cte, just validated)
	     */
	    generator::Generator validateTemplateTest (const Symbol & context, const syntax::Expression & expr);

	    /**
	     * Validate a symbol created by templateSpecialization
	     * @param ref is the reference of the template (sometimes it is a MethodTemplateRef and need to be treated like that)
	     */
	    void validateTemplateSymbol (const semantic::Symbol & sym, const generator::Generator & ref);

	    /**
	     * Validate a template call expression
	     */
	    generator::Generator validateTemplateCall (const syntax::TemplateCall & cl);

	    /**
	     * insert a new prototype
	     * @return false if the proto already exists, true otherwise
	     */
	    void insertErrorTemplateSolution (const semantic::Symbol & sol, const std::list <Ymir::Error::ErrorMsg> & errors);

	    /**
	     * Remove a template solution
	     */
	    void removeErrorTemplateSolution (const semantic::Symbol & sol);

	    
	    /**
	     * insert a new prototype
	     * @return false if the proto already exists, true otherwise
	     */
	    bool insertTemplateSolution (const semantic::Symbol & sol, std::list <Ymir::Error::ErrorMsg> & errors);

	    /**
	     * Remove a template solution
	     */
	    void removeTemplateSolution (const semantic::Symbol & sol);

	    /**
	     * Validate a template generated list of generator (it will create a tuple)
	     */
	    generator::Generator validateListTemplate (const generator::TemplateSyntaxList & list);
	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * =================================     MACROS     ===============================
	     * ================================================================================
	     * ================================================================================
	     */
	    
	    /**
	     * Validate the content of a macro expression, created by a MacroVisitor, invoked by a MacroCall
	     */
	    generator::Generator validateMacroExpression (const semantic::Symbol & sol, const syntax::Expression & expr);

	    /**
	     * Validate a macro call
	     */
	    generator::Generator validateMacroCall (const syntax::MacroCall & call);

	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * =================================      TYPES     ===============================
	     * ================================================================================
	     * ================================================================================
	     */
	    
	    /**
	     * validate an expression, that produce a type
	     * @return a generator containing the resulting type
	     * @param lock if the return type is not mutable do we lock the mutability ?
	     * @      if true, even if we set it to mutable later all the inner types will be immutable
	     */
	    generator::Generator validateType (const syntax::Expression & type, bool lock);

	    /**
	     * validate an expression, that produce a type, if it failed with validateType (so it must be a ClassRef)
	     * @return a generator containing the resulting type
	     * @param lock if the return type is not mutable do we lock the mutability ?
	     * @      if true, even if we set it to mutable later all the inner types will be immutable
	     */
	    generator::Generator validateTypeClassRef (const syntax::Expression & type, bool lock);

	    /**
	     * validate an expression, that produce a type
	     * @return a generator containing the resulting type
	     */
	    generator::Generator validateType (const syntax::Expression & type);
	    
	    /**
	     * validate an expression, that produce a type, if it failed with validateType (so it must be a ClassRef)
	     * @return a generator containing the resulting type
	     */
	    generator::Generator validateTypeClassRef (const syntax::Expression & type);

	    /**
	     * Validate a decorated type
	     * @param canBeClassRef, true if it can be a class ref (from a UnaryOp type creation)
	     */
	    generator::Generator validateTypeDecorated (const syntax::DecoratedExpression & type, bool canBeClassRef = false);
	    
	    /**
	     * Validate the var using it as a type
	     */
	    generator::Generator validateTypeVar (const syntax::Var & var);

	    /**
	     * Validate the unary using it as a type (for &() for example)
	     */
	    generator::Generator validateTypeUnary (const syntax::Unary & var);

	    /**
	     * Validate the unary using it as a type (for (i32)? for example)
	     */
	    generator::Generator validateTypeTry (const syntax::Try & tr);
	    
	    /**
	     * Validate an array allocation as a type
	     */
	    generator::Generator validateTypeArrayAlloc (const syntax::ArrayAlloc & alloc);

	    /**
	     * Validate a slice type from an array literal
	     */
	    generator::Generator validateTypeSlice (const syntax::List & array);
	    
	    /**
	     * Validate a tuple type from a tuple literal
	     */
	    generator::Generator validateTypeTuple (const syntax::List & tuple);

	    /**
	     * Validate a type from a range type expression
	     */
	    generator::Generator validateTypeRange (const syntax::RangeType & rng);
	    
	    /**
	     * Validate a tuple type from a template syntax list
	     */
	    generator::Generator validateTypeTupleTemplate (const generator::TemplateSyntaxList & tuple);

	    /**
	     * @return the typeinfo of the type type
	     */
	    generator::Generator validateTypeInfo (const lexing::Word & loc, const generator::Generator & type, bool force = false);

	    /**
	     * @return the name of the field in TypeIDs for the type type
	     */
	    static std::string typeInfoName (const generator::Generator & type);

	    /**
	     * Validate a func ptr type (fn or dg) into generate type
	     */
	    generator::Generator validateFuncPtr (const syntax::FuncPtr & ptr);

	    /**
	     * Validate a type from a class context
	     */
	    generator::Generator validateTypeClassContext (const lexing::Word & loc, const generator::Generator & cl, const syntax::Expression & type);

	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * ==============================      STATEMENTS     =============================
	     * ================================================================================
	     * ================================================================================
	     */
	    
	    
	    /**
	     * Validate a throw expression
	     */
	    generator::Generator validateThrow (const syntax::Throw & thr);

	    /**
	     * Validate a match expression
	     */
	    generator::Generator validateMatch (const syntax::Match & matcher);

	    /**
	     * Validate an assert
	     */
	    generator::Generator validateAssert (const syntax::Assert & assert);

	    /**
	     * Validate an assert at compile time,
	     */
	    generator::Generator validateCteAssert (const syntax::Assert & assert);
	    

	    /**
	     * Validate a pragma
	     */
	    generator::Generator validatePragma (const syntax::Pragma & prg);

	    /**
	     * Validate a with expression
	     */
	    generator::Generator validateWith (const syntax::With & wh);

	    /**
	     * Validate an atomic expression
	     */
	    generator::Generator validateAtomic (const syntax::Atomic & atom);

	    /**
	     * Validate an if expression
	     * @return as always a generator
	     * @warning the generator is not always a if expression, for optimization purpose (such as the test is always false, ...)
	     */
	    generator::Generator validateIfExpression (const syntax::If & _if);

	    /**
	     * Validate an if expression and evaluate it at compile time
	     * @return as always a generator
	     */
	    generator::Generator validateCteIfExpression (const syntax::If & _if);
	    
	    /**
	     * Validate a while expression
	     * @return as always a generator
	     */
	    generator::Generator validateWhileExpression (const syntax::While & _wh);

	    /**
	     * Validate a for expression
	     * @return as always a generator
	     */
	    generator::Generator validateForExpression (const syntax::For & _for, bool isCte = false);
	    
	    /**
	     * Validate a break expression
	     */
	    generator::Generator validateBreak (const syntax::Break & br);

	    /**
	     * Validate a return expression
	     */
	    generator::Generator validateReturn (const syntax::Return & rt);

	    /**
	     * Validate a cast expression
	     */
	    generator::Generator validateCast (const syntax::Cast & cast);
	    
	    /**
	     * Validate a destruct declaration
	     */
	    generator::Generator validateDestructDecl (const syntax::DestructDecl & decl);

	    /**
	     * Validate a var declaration inside a block (or a frame)
	     * @param needValue Is the value mandatory in this var declaration?
	     */
	    generator::Generator validateVarDeclValue (const syntax::VarDecl & decl, bool needValue = true);

	    /**
	     * Validate a try expression
	     */
	    generator::Generator validateTry (const syntax::Try & tr);

	    /**
	     * ================================================================================
	     * ================================================================================
	     * ===============================     INTRINSICS    ==============================
	     * ================================================================================
	     * ================================================================================
	     */
	    
	    /**
	     * Validate intricisics, it could be either :
	     * - a copy
	     * - an expand
	     * - type informations ...
	     */
	    generator::Generator validateIntrinsics (const syntax::Intrinsics & intr);
	    	    
	    /**
	     * Validate the copy intrinsics
	     */
	    generator::Generator validateCopy (const syntax::Intrinsics & intr);

	    /**
	     * Validate the deep copy intrinsics
	     */
	    generator::Generator validateDeepCopy (const syntax::Intrinsics & intr);

	    /**
	     * Validate the alias intrinsics
	     */
	    generator::Generator validateAlias (const syntax::Intrinsics & intr);

	    /**
	     * Validate the expand intrinsics
	     */
	    generator::Generator validateExpand (const syntax::Intrinsics & intr);

	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * ===============================      LITERALS     ==============================
	     * ================================================================================
	     * ================================================================================
	     */
	    	    
	    
	    /**
	     * Validate a dollar expression
	     */
	    generator::Generator validateDollar (const syntax::Dollar & dl);

	    
	    /**
	     * Validate an fixed const integer value
	     */
	    generator::Generator validateFixed (const syntax::Fixed & fixed, int base = 0);
	    
	    /**
	     * Validate a const bool value
	     */
	    generator::Generator validateBool (const syntax::Bool & b);

	    /**
	     * Validate a const floating value
	     */
	    generator::Generator validateFloat (const syntax::Float & f);

	    /**
	     * Validate a literal char
	     */
	    generator::Generator validateChar (const syntax::Char & c);

	    /**
	     * Validate a string literal
	     */
	    generator::Generator validateString (const syntax::String & s, bool forceUtf8 = false);
	    	    
	    /**
	     * Validate a list, it could be either :
	     * - an array
	     * - a tuple
	     * - an array type
	     * - a tuple type
	     */
	    generator::Generator validateList (const syntax::List & list);

	    /**
	     * Validate an array alloc
	     */
	    generator::Generator validateArrayAlloc (const syntax::ArrayAlloc & alloc);

	    /**
	     * Validate a lambda function
	     */
	    generator::Generator validateLambda (const syntax::Lambda & lmbd);

	    /**
	     * Validate a lambda proto that is validated by calling it
	     */
	    generator::Generator validateLambdaProto (const generator::LambdaProto & lmbd, const std::vector <generator::Generator> & types);

	    /**
	     * Create the closure value, that will be passed in the delegate value
	     * A closure value is a copy or a ref to all the enclosed variable in a tuple value that is then copied to heap
	     */
	    generator::Generator validateClosureValue (const generator::Generator & closureType, bool isrefClosure, uint closureIndex);

	    /**
	     * Validate a null value
	     */
	    generator::Generator validateNullValue (const syntax::Null & nl);

	    /**
	     * validate an array literal
	     */
	    generator::Generator validateArray (const syntax::List & list);

	    /**
	     * validate an tuple literal
	     */
	    generator::Generator validateTuple (const syntax::List & list);
	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * =================================      BLOCKS     ==============================
	     * ================================================================================
	     * ================================================================================
	     */
	    	    
	    
	    /**
	     * Validate a scope guard (this function must be called only if this scope is out from any scope)
	     * @param sc the scope guard to validate
	     */
	    generator::Generator validateScopeOutOfScope (const syntax::Scope & sc);


	    /**
	     * Validate a catch (this function must be called only if this catch is out from any scope)
	     * @param cat the catcher to validate
	     */
	    generator::Generator validateCatchOutOfScope (const syntax::Catch & cat);
	    
	    /**
	     * Validate a block of expression
	     * @return a tree containing the result of the block
	     */
	    generator::Generator validateBlock (const syntax::Block & block, const std::vector <generator::Generator> & init = {});

	    /**
	     * Validate the content of a block (the values)
	     * @returns:
	     *    - values: the list of values inside the block
	     *    - type: the type of the block
	     *    - valueLoc: the location of the last value giving the type of the block
	     *    - returner: the content of the block necessarily return at some point
	     *    - rtLoc: the location of the returner
	     *    - breaker: the content of the block necessarily breaks
	     *    - brLoc: the location of the breaker
	     */
	    void validateInnerBlock (const syntax::Block & block, std::vector <generator::Generator> & values, generator::Generator & type, lexing::Word & valueLoc, bool & returner, lexing::Word & rtLoc, bool & breaker, lexing::Word& brLoc, std::list <Ymir::Error::ErrorMsg> & errors);

	    /**
	     * Validate a catch block
	     * return by ref the vardecls and actions to perform in case of catch
	     * All the actions must return the type type (if type !is void)
	     * The type of the block may change, in case of common ancestor
	     */
	    void validateCatcher (const syntax::Block & block, generator::Generator & varDecl, generator::Generator & typeInfos, generator::Generator & actions, generator::Generator& type, const std::vector <generator::Generator> & throwsTypes, std::list <Ymir::Error::ErrorMsg> & errors);

	    /**
	     * Validate the scope parts of a block (exit, failure and success)
	     */
	    void validateScopes (const syntax::Block & block, std::vector <generator::Generator> & onExit, std::vector <generator::Generator> & onSuccess, std::vector <generator::Generator> & onFailure, bool & returner, bool & breaker, bool hasThrowers, std::list <Ymir::Error::ErrorMsg> & errors);
	    
	    /**
	     * Validate an inner declaration of a module
	     * @param decl the module to declare, and validate
	     */
	    semantic::Symbol validateInnerModule (const syntax::Declaration & decl, std::list <Ymir::Error::ErrorMsg> & errors);

	    /**
	     * Validate a set of expression
	     * @return a tree containing the result of the block
	     */
	    generator::Generator validateSet (const syntax::Set & set);
	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * =================================      VALUES     ==============================
	     * ================================================================================
	     * ================================================================================
	     */
	    	    
	    
	    /**
	     * Validate a value, and ensure that it has a type and not a void type
	     * @return a tree containing the value
	     */
	    generator::Generator validateValueNonVoid (const syntax::Expression & expr);
	    
	    /**
	     * validate an expression, that produce a value
	     * If the value is a breaker or a returner throw an error
	     * @return a tree containing the result of the value
	     */
	    generator::Generator validateValue (const syntax::Expression & value, bool canBeType = false, bool fromCall = false, bool checkReach = false, bool fromValidateType = false);

	    /**
	     * Validate an compile time expression , that produce a value
	     * If the value is a breaker or a returner throw an error
	     * @return a tree containing the result of the value
	     */
	    generator::Generator validateCteValue (const syntax::Expression & value);
	    
	    /**
	     * validate an expression, that produce a value
	     * @return a tree containing the result of the value
	     */
	    generator::Generator validateValueNoReachable (const syntax::Expression & value, bool fromCall = false);

	    	    	    	    
	    /**
	     * execute the content of the generator in order to retreive the compile time value
	     */
	    generator::Generator retreiveValue (const generator::Generator & gen);


	    /**
	     * ================================================================================
	     * ================================================================================
	     * =================================    OPERATORS    ==============================
	     * ================================================================================
	     * ================================================================================
	     */
	   	   	    	    	    
	    /**
	     * Validate a binary expression
	     * This generation is a bit complex as it depends on the type of the operands
	     * All binary operations are handled by BinaryVisitor class
	     */
	    generator::Generator validateBinary (const syntax::Binary & bin, bool isFromCall = false);

	    /**
	     * Validate a unary expression
	     * All unary operations are handled by UnaryVisitor class
	     */
	    generator::Generator validateUnary (const syntax::Unary & un);

	    /**
	     * Validate a mult operator
	     * A mult operator is an operator with one left operand and multiple right operand
	     * It can be either :
	     * - Brackets
	     * - Parentheses
	     */
	    generator::Generator validateMultOperator (const syntax::MultOperator & mult);
	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * ===============================    VARS AND REFS    ============================
	     * ================================================================================
	     * ================================================================================
	     */
	   	   	    	    	    
	    /**
	     * Validate a var
	     * It will check all the local reference
	     * If no local reference are found, it will find the symbol inside the table of the current frame
	     * And then produce the generator for this symbol
	     */
	    generator::Generator validateVar (const syntax::Var & var);

	    /**
	     * Transform global extern symbol into valid generators
	     * @param loc the location of the reference to those symbols
	     * @param multSym the list of symbols
	     * @param fromTemplate allow from template frame prototype
	     */
	    generator::Generator validateMultSym (const lexing::Word & loc, const std::vector <Symbol> & multSym);

	    /**
	     * Transform global extern symbol into valid generators
	     * @param loc the location of the reference to those symbols
	     * @param multSym the list of symbols
	     */
	    generator::Generator validateMultSymType (const lexing::Word & loc, const std::vector <Symbol> & multSym);
	    	    
	    /**
	     * Validate a decorated expression
	     */
	    generator::Generator validateDecoratedExpression (const syntax::DecoratedExpression & dec_expr);

	    /**
	     * Validate a mult sym proto,
	     */
	    generator::Generator validateMultSymProto (const generator::Generator & sym, const std::vector <generator::Generator> & types);
	    

	    /**
	     * ================================================================================
	     * ================================================================================
	     * ================================   VERIFICATIONS  ==============================
	     * ================================================================================
	     * ================================================================================
	     */
	    	    	  	    

	    /**
	     * this function is called each time a copy is performed
	     * @param loc the location of the affectation
	     * @param type the type result of the copy
	     * @param gen the generator that will produce the affectation
	     * @param construct is this a construction ? (ref are not affected yet)
	     * This function verify that the mutability of gen is preserved
	     * And that no implicit operation are performed
	     */
	    void verifyMemoryOwner (const lexing::Word & loc, const generator::Generator & type, const generator::Generator & gen, bool construct, bool checkTypes = true, bool inMatch = false);


	    /**
	     * Verify the level of mutability of the left and right type (left <- right)
	     */
	    void verifyMutabilityLevel (const lexing::Word & loc, const lexing::Word & rloc, const generator::Generator & leftType, const generator::Generator & rightType, bool construct);
	    
	    /**
	     * Verify that if the type must be copied or aliased, the generator gives an explicitly alias construction
	     */
	    void verifyImplicitAlias (const lexing::Word & loc, const generator::Generator & type, const generator::Generator & gen);

	    /**
	     * Verify that the type is complete and can be used at runtime to store value
	     */
	    void verifyCompleteType (const lexing::Word & loc, const generator::Generator & type);

	    /**
	     * Verify that a parameter (of a function, or a for loop or ...) is mutable iif it is a reference
	     * There is some exception, you must call this function to verify the correct behavior
	     * @param loc the location of the variable declaration
	     * @param type the type of the var
	     * @param error the error to throw, (in case of error)
	     */
	    void verifyMutabilityRefParam (const lexing::Word & loc, const generator::Generator & type, const char* error);

	    /**
	     * Throw an exception if left.equals (right) is false
	     * @param left a type
	     * @param rigth a type
	     */
	    void verifySameType (const generator::Generator & left, const generator::Generator & right);

	    /**
	     * Throw an exception if left.equals (right) is false
	     * @param left a type
	     * @param rigth a type
	     */
	    void verifyCompleteSameType (const generator::Generator & left, const generator::Generator & right);
	    
	    /**
	     * Verify that the class cl implement the trait tr

	     */
	    void verifyClassImpl (const lexing::Word & loc, const generator::Generator & cl, const syntax::Expression & tr);

	    /**
	     * Verify that the class cl implement the trait tr
	     * @params: 
	     *   - thr: if thr is true, then throw errors if the class does not impl
	     * @returns: true if the class impl, false otherwise (if !thr)
	     */
	    bool verifyClassImpl (const lexing::Word & loc, const generator::Generator & cl, const generator::Generator & tr, bool thr = true);

	    /**
	     * Throw an exception if left.isCompatible (right) is false
	     * @param left a type
	     * @param right a type
	     * @param fromObject, if the left type is an &core::object::Object, and right is a ClassPtr, then the type is compatible iif fromObject
	     */
	    void verifyCompatibleType (const lexing::Word & loc, const lexing::Word & rightLoc, const generator::Generator & left, const generator::Generator & right, bool fromObject = false);

	    
	    /**
	     * Throw an exception if left.isCompatible (right.getType ()) is false
	     * @param left a type
	     * @param right a value
	     */
	    void verifyCompatibleTypeWithValue (const lexing::Word & loc, const generator::Generator & left, const generator::Generator & right);


	    /**
	     * Throw an exception if there is already some var named name
	     * @param name the forbidden name
	     */
	    void verifyShadow (const lexing::Word & name);

	    /**
	     * Throw an exception if name refer to a primitive type
	     * @param the possibly forbidden name
	     */
	    void verifyNotIsType (const lexing::Word & name);

	    /**
	     * Verify that a given value is not locked for aliasing
	     */
	    void verifyLockAlias (const generator::Generator & gen);
	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * =================================      TESTS     ===============================
	     * ================================================================================
	     * ================================================================================
	     */
	    	    	  
	    
	    /**
	     * @return true, if we can make an implicit alias of the value
	     */
	    bool canImplicitAlias (const generator::Generator & value);

	    /**
	     * Is the type a void array
	     */
	    bool isVoidArrayType (const generator::Generator & type);

	    /**
	     * @return true if left is a classRef that is an ancestor of right also a classref
	     */
	    static bool isAncestor (const generator::Generator & left, const generator::Generator & right);
	    
	    /**
	     * Is the value known at compile time and is a fixed constant
	     */
	    bool isIntConstant (const generator::Generator & val);

	    /**
	     * Is the value known at compile time and is a float const
	     */
	    bool isFloatConstant (const generator::Generator & val);

	    /**
	     * Is the type the object type
	     */
	    bool isObjectType (const generator::Generator & type);
	    
	    /**
	     * Tell if an expression use alone has any effect, or if it is just a lost of computation power
	     * @param gen the expression to test
	     */
	    bool isUseless (const generator::Generator & gen);

	    /**
	     * @returns: a stringvalue if the the generator can be transformed in a string literal, empty otherwise
	     */
	    generator::Generator isStringLiteral (const generator::Generator & gen);
	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * ===================================   GETTERS  =================================
	     * ================================================================================
	     * ================================================================================
	     */
	    
	    /**
	     * Applicable to the type of a vardecl,
	     * @param decos the decorators of the variable (and not of the type)
	     * @param type the type of the var declaration
	     * @return isRef ref decorator found
	     * @return isMutable mut decorator found
	     */
	    generator::Generator applyDecoratorOnVarDeclType (const std::vector <syntax::DecoratorWord> & decos, const generator::Generator & type, bool & isRef, bool & isMutable, bool & dmut, bool & isPure, bool canBeRef = true, bool canBeMut = true, bool canBeDmut = true, bool canBePure = true);

	    
	    /**
	     * @return the list of all implemented traits in the class cl
	     */
	    std::vector <generator::Generator> getAllImplClass (const generator::Generator & cl);

	    /**
	     * Get the current context for class access
	     * @param cl a class symbol that we want to access
	     * @param isPrivate return by ref, will be true if we have the right to access to private elements of cl
	     * @param isProtected return by ref, will be true if we have the right to access to protected elements of cl
	     * @info as public is always true, it is not a parameter here
	     */
	    void getClassContext (const semantic::Symbol & cl, bool & isPrivate, bool & isProtected);

	    /**
	     * Get the current context for a macro access
	     */
	    void getMacroContext (const semantic::Symbol & cl, bool & isPrivate);

	    /**
	     * @return the list of (in a multsym) of the constructor of the class cl
	     * @warning cl is assumed to be a generator::Class
	     */
	    generator::Generator getClassConstructors (const lexing::Word & loc, const generator::Generator & cl, const lexing::Word & name);

	    /**
	     * @return the list of constructor of the macro
	     */
	    std::vector <semantic::Symbol> getMacroConstructor (const lexing::Word & loc, const generator::MacroRef & mref);

	    /**
	     * @return the list of macro rule of the macro
	     * @param name the name of the rule
	     */
	    std::vector <semantic::Symbol> getMacroRules (const lexing::Word & loc, const generator::MacroRef & ref, const std::string & name);

	    /**
	     * @return the list of macro rules of the current macro context
	     * @param name the name of the rule
	     */
	    semantic::Symbol getCurrentMacroRules (const lexing::Word & loc, const std::string & name);
	    
	    /**
	     * @return the list of constructors declared in the class
	     */
	    std::vector <syntax::Declaration> getAllConstructors (const std::vector <syntax::Declaration> & innerClass, const lexing::Word & name);
	    
	    /**
	     * Get the current context of the current state
	     * If mod is an ancestor of the current ref, return will be true
	     * It means that all the private declaration of mod can be accessed in the current state
	     */
	    bool  getModuleContext (const semantic::Symbol & mod);

	    	    
	    /**
	     * @returns: the common ancestor from two class refs (or classptrs)
	     */
	    generator::Generator getCommonAncestor (const generator::Generator & left, const generator::Generator & right);


	    /**
	     * @returns: the struct TypeInfo in core::typeinfo
	     */
	    generator::Generator getTypeInfoType ();

	    /**
	     * @returns: the enum TypeIDS in core::typeinfo
	     */
	    generator::Generator getTypeInfoIds ();

	    /**
	     * @returns: the function outofarray
	     */
	    generator::Generator getOutOfArrayCall (const lexing::Word & loc);

	    /**
	     * @returns: the trait Disposable
	     */
	    generator::Generator getDisposeTrait ();

	    /**
	     * @returns: the type Exception
	     */
	    generator::Generator getExceptionType ();

	    /**
	     * @returns: the Object type
	     */
	    generator::Generator getObjectType ();

	    /**
	     * @returns: the SegFault type
	     */
	    generator::Generator getSegFault ();
	    
	    /**
	     * @return the cache of the visitor
	     */
	    const VisitorCache & getCache () const;
	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * ===============================     INFERENCES    ==============================
	     * ================================================================================
	     * ================================================================================
	     */


	    /**
	     * Deduce the type that can be used as a common ancestor type for left and right
	     * Might no throw anything even if left and right are incompatible, must verify the compatibility afterwards, between type, left and right
	     */
	    generator::Generator inferTypeBranching (const lexing::Word & lloc, const lexing::Word & rloc, const generator::Generator & left, const generator::Generator & right);

	    /**
	     * Deduce the type that can be used as a common ancestor type for left and right
	     * Might no throw anything even if left and right are incompatible, must verify the compatibility afterwards, between type, left and right
	     */
	    generator::Generator inferTypeBranchingWithValue (const lexing::Word & lloc, const lexing::Word & rloc, const generator::Generator & leftValue, const generator::Generator & rightType);


	    /**
	     * ================================================================================
	     * ================================================================================
	     * ================================       ERRORS     ==============================
	     * ================================================================================
	     * ================================================================================
	     */
	    
	    /**
	     * @throw the error saying that left and right are incompatible types
	     */
	    void throwIncompatibleTypes (const lexing::Word & loc, const lexing::Word & rightLoc, const generator::Generator & left, const generator::Generator & right, const std::list <Ymir::Error::ErrorMsg> & notes);


	    /**
	     * ================================================================================
	     * ================================================================================
	     * =============================   SCOPE MANAGEMENT  ==============================
	     * ================================================================================
	     * ================================================================================
	     */

	    
	    /**
	     * Enter a foreign definition
	     * all the symbol currently declared in local block won't be accessible until we exit the foreign
	     */
	    void enterForeign ();

	    /**
	     * exit the foreign (Cf. enterForeign)
	     */
	    void exitForeign ();
	    
	    /**
	     * Enter a new closure
	     */
	    void enterClosure (bool isRefClosure, uint refId, uint index);

	    /**
	     * Quit a closure
	     * @returns all the enclosed vars
	     */
	    generator::Generator exitClosure ();
	    
	    /**
	     * enter a new context,
	     * A context is a list of Cas (only used in a function)
	     * This list define the behavior that are not allowed
	     */
	    void enterContext (const std::vector <lexing::Word> & Cas);

	    /**
	     * Exit the context (Cf. enterContext)
	     */
	    void exitContext ();

	    /**
	     * enter a new class context
	     */
	    void enterClassDef (const semantic::Symbol & sym);


	    /**
	     * Exit a class context (Cf. enterClassDef)
	     */
	    void exitClassDef (const semantic::Symbol & sym);

	    	    
	    
	    /**
	     * @return does the current context include context
	     */
	    bool isInContext (const std::string & context);

	    /**
	     * Tell if the current context allows trusted declarations
	     */
	    bool isInTrusted () const;

	    
	    /**
	     * Enter a new scope
	     */
	    void enterBlock ();

	    /**
	     * Lock the possibility of alias the content of gen for a moment
	     */
	    void lockAliasing (const lexing::Word & loc, const generator::Generator & gen);

	    /**
	     * Unlock the possibility of alias the content of gen
	     */
	    void unlockAliasing (const generator::Generator & gen);
	    
	    /**
	     * Exit a scope
	     */
	    void quitBlock (bool warnUnused);

	    /**
	     * Exit the scope, but return the errors inside errors,
	     */
	    void quitBlock (bool warnUnused, std::list <Ymir::Error::ErrorMsg> & errors);
	    
	    /**
	     * Ignore all the local var declared in the current block
	     * @return all the local var discarded
	     */
	    std::map <std::string, generator::Generator> discardAllLocals ();
	    
	    /**
	     * Enter a new breakable loop
	     */
	    void enterLoop ();
	    
	    /**
	     * quit a breakable loop
	     * @return the type of the inner breakers
	     */
	    generator::Generator quitLoop ();

	    /**
	     * Enter a new dollar context
	     */
	    void enterDollar (const generator::Generator & gen);

	    /**
	     * Quit a dollar context
	     */
	    void quitDollar ();


	    /**
	     * @return the loop type
	     */
	    const generator::Generator & getCurrentLoopType () const;

	    /**
	     * Change the type of the current loop
	     */
	    void setCurrentLoopType (const generator::Generator & type);

	    /**
	     * Return the type of the current fn
	     */
	    generator::Generator getCurrentFuncType () ;

	    /**
	     * Set the type of the current fn
	     */
	    void setCurrentFuncType (const generator::Generator & type);
	    
	    /**
	     * @return !this-> _loopBreakTypes.empty ()
	     */
	    bool isInLoop () const;

	    /**
	     * @return true if we are validating a closure
	     */
	    bool isInClosure ();

	    /**
	     * @return true if we are validating a closure and it is a ref one
	     */
	    bool isInRefClosure ();

	    /**
	     * Get a variable in the encosed element
	     */
	    generator::Generator getInClosure (const std::string & name);
	    
	    /**
	     * insert a new symbol in the frame local scope
	     * @param name the name of the symbol
	     * @param local the symbol
	     */
	    void insertLocal (const std::string & name, const generator::Generator & local);
	    
	    /**
	     * Get a localy declared symbol
	     * @param name the name of the symbol to get
	     */
	    generator::Generator getLocal (const std::string & name, bool canBeInClosure = true) ;


	    /**
	     * Retreive a globally declared symbol (outside of the frame, or inner declared but not local just private)
	     * @param name the name of the symbol to retreive
	     */
	    std::vector <Symbol> getGlobal (const std::string & name);


	    /**
	     * Retreive a globally declared symbol (outside of the frame, or inner declared but not local just private)
	     * @param name the name of the symbol to retreive
	     */
	    std::vector <Symbol> getGlobalPrivate (const std::string & name);

	    /**
	     * this-> _referent.push_back (sym)
	     */
	    void pushReferent (const semantic::Symbol & sym, const std::string & msg);

	    /**
	     * this-> _referent.pop_back ()
	     */
	    void popReferent (const std::string & msg);

	    /**
	     * Insert a new class to validate
	     */
	    void insertClassValidation (const semantic::Symbol & sym);

	    /**
	     * ================================================================================
	     * ================================================================================
	     * ==============================        UTILS        =============================
	     * ================================================================================
	     * ================================================================================
	     */

	    /**
	     * Create an expression, that evaluated will have a value pointing to the var at a given path
	     * This function can be used to easily refers to variable defined in core files for example
	     * Such a getting the Object class, by creating the var {"core", "object", "Object"}.
	     */
	    syntax::Expression createVarFromPath (const lexing::Word & loc, const std::vector <std::string> & path);

	    /**
	     * Does approximately the same as createVarFromPath, but add an unary expression around tha var to create a ClassPtr once evaluated.
	     * For example, this function can be used to get an excpetion defined in a core file
	     */
	    syntax::Expression createClassTypeFromPath (const lexing::Word & loc, const std::vector <std::string> & path);

	    /**
	     * Append a else to a conditional (recursively)
	     * This will appen an else statement at the end of a list of conditional, for example, with the following conditional:
	     * ===================
	     * (if (test1) { value1 } else if (test2) { value2 }).addElseToConditional ({value3}), =>
	     *     (if (test1) { value1 } else if (test2) { value2 } else { value3 }
	     * ===================
	     * The value added can obviousely be a if conditional
	     */
	    generator::Generator addElseToConditional (const generator::Generator & cond, const generator::Generator & _else);

	    /**
	     * Transform a conditional to a complete conditional (meaning we assure that all the test covers every cases, and thus we enter a branch no matter what)
	     * This doesn't add anything to the conditional, but is used to remove some errors in the compiler, such as incompatible types with void as there is no final else
	     * This function can be used when we can ensure the every if condition covers every cases, for example in a pattern matching (or a catcher)
	     */
	    generator::Generator setCompleteConditional (const generator::Generator &cond);


	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * =============================  GENERATION INTERFACE  ===========================
	     * ================================================================================
	     * ================================================================================
	     */
	    	    	  	    
	    /**
	     * @return the list of generator produced by semantic validation
	     */
	    const std::vector <generator::Generator> & getGenerators () const;	    

	    /**
	     * Insert a new Generator that has passed the semantic validation
	     * All the symbol passed here, will be transformed at generation time
	     * @param generator the valid generator
	     */
	    void insertNewGenerator (const generator::Generator & generator);


	    /**
	     * Try to retreive the frame from the prototype
	     * Basically a by name search
	     * @warning can return an empty generator, if the frame was not found
	     */
	    const generator::Generator & retreiveFrameFromProto (const generator::FrameProto & proto);
	    
	    /**
	     * ================================================================================
	     * ================================================================================
	     * =============================         DEBUG          ===========================
	     * ================================================================================
	     * ================================================================================
	     */
	    
	    /**
	     * Print the variable in the local scopes, for debugging purposes
	     */
	    void printLocal () const;
	    
	};
	       
    }
    
}
