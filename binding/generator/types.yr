mod binding::generator::types;

import ymirc::semantic::generator::_;
import ymirc::semantic::symbol::base;
import ymirc::utils::_;
import ymirc::lexing::word;
import ymirc::syntax::keys;

import binding::tree::_;
import binding::generator::visitor;

import std::collection::vec;
import std::collection::map;
import std::collection::set;

import std::fs::path;

import std::io;

/**
 * This visitor class transform ymirc types into GCC trees
 * */
pub class GenerateTypeVisitor {

    // The set of classes being currently generated
    let dmut _classCurrent = HashSet!{&Path}::new ();

    // The set of classes that have already been validated
    let dmut _classDones = HashMap!{&Path, tree_t}::new ();

    /**
     * Create an empty visitor
     * */
    pub self () {}

    /**
     * Transform a type into a tree
     * @params:
     *     - context: the context of the generation
     *     - type: the type to generate
     * @returns: a GCC tree
     * */
    pub fn generate (mut self, dmut context : &GenerateVisitor, type : &Type)-> tree_t {
        match type {
            n : &NativeType => { self:.generateNative (alias context, n) }
            s : &StructType => return self:.generateStruct (alias context, s);
            c : &ClassPtrType => { self:.generateClassPtr (alias context, c) }
            c : &ClassRefType => { self:.generateClassRef (alias context, c) }
            _ => {
                eprintln (type::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        CLASS        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a class pointer type
     * @params:
     *     - context: the context of the generation
     *     - type: the class ptr to generate
     * @returns: a tree type
     * */
    fn generateClassPtr (mut self, dmut context : &GenerateVisitor, type : &ClassPtrType)-> tree_t {
        let inner = self:.generateClassRef (alias context, type.getInner ());
        let ptr = c_binding_build_pointer_type (inner);
        ptr
    }

    /**
     * Generate a class reference type (vtable, and )
     * @params:
     *     - context: the context of the generation
     *     - name: the name of the symbol
     *     - type: the type to generate
     * @returns: the type tree
     * */
    fn generateClassRef (mut self, dmut context : &GenerateVisitor, type : &ClassRefType)-> tree_t {
        let sym = type.getSymbol ();
        let name = sym.getPath ();

        match self._classDones.find (name) {
            Ok (t : tree_t) => { return t; }
        }
        match name in self._classCurrent {
            true => { voidTypeTree () }
            _ => {
                self._classCurrent:.insert (name);
                let retType = {
                    let dmut fields = Vec!{[c8]}::new ();
                    let dmut types = Vec!{tree_t}::new ();
                    fields:.push ("#_vtable"s8);
                    fields:.push ("#_monitor"s8);
                    types:.push (c_binding_build_pointer_type (c_binding_build_pointer_type (voidTypeTree ())));
                    types:.push (c_binding_build_pointer_type (c_binding_build_pointer_type (voidTypeTree ())));

                    for it in type.getFields () {
                        match it {
                            v : &VarDeclValue => {
                                fields:.push (v.getLoc ().str ());
                                types:.push (context:.generateType (v.getVarType ()));
                            }
                            _ => __pragma!panic ();
                        }
                    }

                    tree::types::tupleTypeTree (name.toStr (sep-> "::"s8), types[], fields[])
                } exit {
                    self._classCurrent:.remove (name);
                };

                self._classDones:.insert (name, retType);
                retType
            }
        }
    }

    /**
     * Generate the global var containing the type info of a class type, and returns its address
     * @params:
     *     - context: the context of the generation
     *     - cl: the class ref whose type info will be generated
     * @returns: the reference to the type info var
     * */
    fn generateClassTypeInfo (self, dmut context : &GenerateVisitor, cl : &ClassRefType)-> tree_t {
        let name = context:.getMangler ().mangleTypeInfo (cl);
        let slcType = types::tupleTypeTree ("slc"s8,
                                            [intTypeTree (0, false), pointerTypeTree (voidTypeTree ())],
                                            [SliceKeys::LEN, SliceKeys::PTR]);

        let ancestorSlice = match cl.getAncestor () {
            anc : &ClassRefType => {
                let ti = self.generateClassTypeInfo (alias context, anc);
                let size = buildIntCst (intTypeTree (0, false), 1u64);

                expr::buildConstructorFields (slcType, [size, addressExprTree (cl.getLoc (), pointerTypeTree (voidTypeTree ()), ti)], [SliceKeys::LEN, SliceKeys::PTR])
            }
            _ => {
                let size = buildIntCst (intTypeTree (0, false), 0u64);
                expr::buildConstructorFields (slcType, [size, context:.getValueVisitor ().generateNullLit (alias context)], [SliceKeys::LEN, SliceKeys::PTR])
            }
        };

        name;
        ancestorSlice;
        __pragma!panic ();
    }

    /**
     * Generate the vtable of a class type
     * @params:
     *    - context: the context of the generation
     *    - type: the class reference whose vtable has to be generated
     * @returns: the global var decl of the vtable
     * */
    pub fn generateVtable (self, dmut context : &GenerateVisitor, cl : &ClassRefType)-> tree_t {
        let type = c_binding_build_array_type (pointerTypeTree (voidTypeTree ()), cast!u64 (cl.getVtable ().len) + 2us);
        let name = context:.getMangler ().mangleVtable (cl);
        let decl = varDeclTree (Word::eof (), name, type);

        let dmut params = Vec!{tree_t}::new ();

        params:.push (self.generateClassTypeInfo (alias context, cl));
        match cl.getDestructor () {
            NoneValue () => {
                params:.push (context:.getValueVisitor ().generateNullLit (alias context));
            }
            _ => {
                params:.push (context:.generateValue (cl.getDestructor ()));
            }
        }

        for mt in cl.getVtable () {
            params:.push (context:.generateValue (mt));
        }

        let vtableValue = expr::buildConstructorIndexed (type, params[]);

        c_binding_set_decl_initial (decl, vtableValue);
        c_binding_set_static (decl, true);
        c_binding_set_used (decl, true);
        c_binding_set_preserved (decl, true);
        c_binding_set_public (decl, true);
        c_binding_set_weak (decl, true);
        c_binding_set_decl_context (decl, tree::decl::ymir_get_global_context ());

        c_binding_insert_global (decl);
        decl
    }

    /**
     * Retreive the global symbol defining the virtual table of a class type (but does not generate it)
     * @params:
     *    - context: the context of the generation
     *    - cl: the class reference whose vtable has to be generated
     * @returns: the var decl of the vtable
     * */
    pub fn retreiveVtable (mut self, dmut context : &GenerateVisitor, cl : &ClassRefType)-> tree_t {
        let type = c_binding_build_array_type (pointerTypeTree (voidTypeTree ()), cast!u64 (cl.getVtable ().len + 2us));
        let name = context:.getMangler ().mangleVtable (cl);
        let decl = varDeclTree (Word::eof (), name, type);

        c_binding_set_static (decl, true);
        c_binding_set_used (decl, true);
        c_binding_set_preserved (decl, true);
        c_binding_set_external (decl, true);
        c_binding_set_public (decl, true);
        c_binding_set_weak (decl, true);
        c_binding_set_decl_context (decl, tree::decl::ymir_get_global_context ());

        decl
    }

    /**
     * =================================================================================
     * =================================================================================
     * ===============================        NATIVE        ============================
     * =================================================================================
     * =================================================================================
     */

    /**
     * Generate a type tree from a native type.
     * */
    fn generateNative (mut self, dmut context : &GenerateVisitor, type : &NativeType)-> tree_t {
        match type {
            i : &IntType =>
                return intTypeTree (cast!i32 (i.getSize ()), i.isSigned ());
            c : &CharType =>
                return charTypeTree (cast!i32 (c.getSize ()));
            f : &FloatType =>
                return floatTypeTree (cast!i32 (f.getSize ()));
            BoolType () => return boolTypeTree ();
            NoneType () => return voidTypeTree ();
            VoidType () => return voidTypeTree ();
            slc : &SliceType => return self:.generateSlice (alias context, slc);
            arr : &ArrayType => return self:.generateArray (alias context, arr);
            p   : &PointerType => return self:.generatePointer (alias context, p);
            t : &TupleType => return self:.generateTuple (alias context, t);
            r : &RangeType => return self:.generateRange (alias context, r);
            _ => {
                eprintln (type::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Generate a pointer type
     * */
    fn generatePointer (mut self, dmut context : &GenerateVisitor, p : &PointerType)-> tree_t {
        let inner = self:.generate (alias context, p.getInners ()[0]);
        pointerTypeTree (inner)
    }

    /**
     * Generate a type tree containing a slice type
     * */
    fn generateSlice (mut self, dmut context : &GenerateVisitor, slc : &SliceType)-> tree_t {
        let inner = self:.generate (alias context, slc.getInners ()[0]);
        let len = intTypeTree (0, false);
        let ptr = pointerTypeTree (inner);

        tupleTypeTree (format ("%", slc),
                       [len, ptr],
                       [SliceKeys::LEN, SliceKeys::PTR])
    }

    /**
     * Generate a type tree for a tuple type
     * */
    fn generateTuple (mut self, dmut context : &GenerateVisitor, tu : &TupleType)-> tree_t {
        let mut inners : [mut tree_t] = [null ; new tu.getInners ().len];
        for i, t in tu.getInners () {
            inners [i] = self:.generate (alias context, t);
        }

        tupleTypeTree (format ("%", tu),
                       inners,
                       [])
    }

    /**
     * Generate a type tree for a struct type
     * */
    fn generateStruct (mut self, dmut context : &GenerateVisitor, s : &StructType)-> tree_t {
        let mut inners : [mut tree_t] = [null ; new s.getFields ().len];
        let mut names : [mut [c8]] = [""s8 ; new s.getFields ().len];
        for i, t in s.getFields () {
            match t {
                v : &VarDeclValue => {
                    names [i] = v.getLoc ().str ();
                    inners [i] = self:.generate (alias context, v.getVarType ());
                }
            }
        }

        tupleTypeTree (format ("%", s), inners, names, isUnion-> s.getSymbol ().isUnion (), isPacked-> s.getSymbol ().isPacked ())
    }

    /**
     * Generate a type tree for a range type
     * */
    fn generateRange (mut self, dmut context : &GenerateVisitor, r : &RangeType)-> tree_t {
        let inner = self:.generate (alias context, r.getInners ()[0]);
        let step = self:.generate (alias context, r.getInners ()[1]);
        let b = boolTypeTree ();

        tupleTypeTree (format ("%", r),
                       [inner, inner, step, b],
                       [RangeKeys::FST, RangeKeys::SCD, RangeKeys::STEP, RangeKeys::CONTAIN])
    }

    /**
     * Generate a type tree containing an array type
     * */
    fn generateArray (mut self, dmut context : &GenerateVisitor, arr : &ArrayType)-> tree_t {
        let inner = self:.generate (alias context, arr.getInners ()[0]);
        c_binding_build_array_type (inner, arr.getSize ().getValue ().to!{u64} ())
    } catch {
        _ => __pragma!panic ();
    }

}
