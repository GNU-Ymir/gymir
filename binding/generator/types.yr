mod binding::generator::types;

import ymirc::semantic::generator::_;
import ymirc::utils::_;
import ymirc::lexing::word;
import ymirc::syntax::keys;

import binding::tree::_;
import binding::generator::visitor;

import std::io;

/**
 * This visitor class transform ymirc types into GCC trees
 * */
pub class GenerateTypeVisitor {

    /**
     * Create an empty visitor
     * */
    pub self () {}

    /**
     * Transform a type into a tree
     * @params:
     *     - context: the context of the generation
     *     - type: the type to generate
     * @returns: a GCC tree
     * */
    pub def generate (self, dmut context : &GenerateVisitor, type : &Type)-> tree_t {
        match type {
            n : &NativeType => self.generateNative (alias context, n);
            _ => {
                eprintln (type::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Generate a type tree from a native type.
     * */
    def generateNative (self, dmut context : &GenerateVisitor, type : &NativeType)-> tree_t {
        match type {
            i : &IntType =>
                return intTypeTree (cast!i32 (i.getSize ()), i.isSigned ());
            c : &CharType =>
                return charTypeTree (cast!i32 (c.getSize ()));
            f : &FloatType =>
                return floatTypeTree (cast!i32 (f.getSize ()));
            BoolType () => return boolTypeTree ();
            NoneType () => return voidTypeTree ();
            VoidType () => return voidTypeTree ();
            slc : &SliceType => return self.generateSlice (alias context, slc);
            arr : &ArrayType => return self.generateArray (alias context, arr);
            _ => {
                eprintln (type::typeinfo.name);
                __pragma!panic ();
            }
        }
    }


    /**
     * Generate a type tree containing a slice type
     * */
    def generateSlice (self, dmut context : &GenerateVisitor, slc : &SliceType)-> tree_t {
        let inner = self.generate (alias context, slc.getInners ()[0]);
        let len = intTypeTree (0, false);
        let ptr = pointerTypeTree (inner);

        tupleTypeTree (format ("%", slc),
                       [len, ptr],
                       [SliceKeys::LEN, SliceKeys::PTR])
    }

    /**
     * Generate a type tree containing an array type
     * */
    def generateArray (self, dmut context : &GenerateVisitor, arr : &ArrayType)-> tree_t {
        let inner = self.generate (alias context, arr.getInners ()[0]);
        c_binding_build_array_type (inner, arr.getSize ().getValue ().to!{u64} ())
    } catch {
        _ => __pragma!panic ();
    }

}
