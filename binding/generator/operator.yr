mod binding::generator::operator;


import ymirc::semantic::generator::_;
import ymirc::utils::_;
import ymirc::lexing::word;
import ymirc::syntax::keys;

import binding::tree::_;
import binding::generator::visitor;

import std::collection::vec;
import std::io;



/**
 * This visitor class transform ymirc operators into GCC trees
 * */
pub class GenerateOperatorVisitor {

    /**
     * Create an empty visitor
     * */
    pub self () {}

    /**
     * Transform an operator value into a tree
     * @params:
     *     - context: the context of the generation
     *     - value: the value to generate
     * @returns: a GCC tree
     * */
    pub def generate (self, dmut context : &GenerateVisitor, value : &OperatorValue)-> tree_t {
        match value {
            a : &AffectValue              => { self.generateAffect (alias context, a) }
            a : &SliceAccessValue         => { self.generateSliceAccess (alias context, a) }
            c : &CallValue                => { self.generateCall (alias context, c) }
            c : &ClassFieldAccessValue    => { self.generateClassFieldAccess (alias context, c) }
            c : &ClosureFieldAccessValue  => { self.generateClosureFieldAccess (alias context, c) }
            c : &CtorCallValue            => { self.generateCtorCall (alias context, c) }
            f : &FuncPtrCallValue         => { self.generateFuncPtrCall (alias context, f) }
            m : &MethodCallValue          => { self.generateMethodCall (alias context, m) }
            n : &NameCallValue            => { self.generateNameCall (alias context, n) }
            s : &SliceCompareValue        => { self.generateSliceCompare (alias context, s) }
            s : &SliceConcatValue         => { self.generateSliceConcat (alias context, s) }
            s : &StructFieldAccessValue   => { self.generateStructFieldAccess (alias context, s) }
            t : &TupleFieldAccessValue    => { self.generateTupleFieldAccess (alias context, t) }
            u : &UnaryOperatorValue       => { self.generateUnaryOperator (alias context, u) }
            b : &BinaryOperatorValue      => { self.generateBinaryOperator (alias context, b) }
            _ => {
                eprintln (value::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        CALLS        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate Call value
     * @params:
     *    - context: the context of the generation
     *    - c: the call value to generate
     * */
    def generateCall (self, dmut context : &GenerateVisitor, c : &CallValue)-> tree_t {
        let mut params : [mut tree_t] = [null ; new (c.getParameters ().len + c.getAddParameters ().len)];
        let dmut pre = TreeStatementList::new ();

        for i, p in c.getParameters () {
            let val = context:.generateValue (p);
            params [i] = c_binding_get_value_operand (val);
            pre:.append (c_binding_get_list_operand (val));
        }

        let j = c.getParameters ().len;
        for i, p in c.getAddParameters () {
            let val = context:.generateValue (p);
            params [i + j] = c_binding_promote (c_binding_get_value_operand (val));
            pre:.append (c_binding_get_list_operand (val));
        }


        let func = context:.generateValue (c.getPrototype ());
        let type = context:.generateType (c.getType ());
        let call = expr::callExprTree (c.getLoc (), type, func, params);

        if (pre.isEmpty ()) {
            call
        } else {
            c_binding_build_compound (pre.getTree (), call)
        }
    }

    /**
     * Generate the call of a class constructor
     * @params:
     *     - context: the context of the generation
     *     - c: the call to generate
     * */
    def generateCtorCall (self, dmut context : &GenerateVisitor, c : &CtorCallValue)-> tree_t {
        context;
        c;
        __pragma!panic ();
    }

    /**
     * Generate a call to a function pointer
     * @params:
     *     - context: the context of the generation
     *     - f: the function pointer to call
     * */
    def generateFuncPtrCall (self, dmut context : &GenerateVisitor, f : &FuncPtrCallValue)-> tree_t {
        context;
        f;
        __pragma!panic ();
    }

    /**
     * Generate a call to a method
     * @params:
     *     - context: the context of the generation
     *     - m: the method call to generate
     * */
    def generateMethodCall (self, dmut context : &GenerateVisitor, m : &MethodCallValue)-> tree_t {
        context;
        m;
        __pragma!panic ();
    }

    /**
     * Generate to the call to a function by its name
     * @params:
     *     - context: the context of the generation
     *     - n: the call value to generate
     * */
    def generateNameCall (self, dmut context : &GenerateVisitor, n : &NameCallValue)-> tree_t {
        context;
        n;
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        SLICES        ===========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Generate a slice comparison value
     * @params:
     *     - context: the context of the generation
     *     - s: the slice compare to generate
     * */
    def generateSliceCompare (self, dmut context : &GenerateVisitor, s : &SliceCompareValue)-> tree_t {
        context;
        s;
        __pragma!panic ();
    }

    /**
     * Generate a slice concatenation value
     * @params:
     *     - context: the context of the generation
     *     - s: the slice concatenation to generate
     * */
    def generateSliceConcat (self, dmut context : &GenerateVisitor, s : &SliceConcatValue)-> tree_t {
        context;
        s;
        __pragma!panic ();
    }


    /**
     * Generate a slice access value
     * @params:
     *     - context: the context of the generation
     *     - a: the slice access to generate
     * */
    def generateSliceAccess (self, dmut context : &GenerateVisitor, a : &SliceAccessValue)-> tree_t {
        context;
        a;
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * ===============================        FIELDS        ===========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Generate a class field access value
     * @params:
     *    - context: the context of the generation
     *    - c: the field access value to generate
     * */
    def generateClassFieldAccess (self, dmut context : &GenerateVisitor, c : &ClassFieldAccessValue)-> tree_t {
        context;
        c;
        __pragma!panic ();
    }

    /**
     * Generate a field access on a closure value
     * @params:
     *     - context: the context of the generation
     *     - c: the closure field access to generate
     * */
    def generateClosureFieldAccess (self, dmut context : &GenerateVisitor, c : &ClosureFieldAccessValue)-> tree_t {
        context;
        c;
        __pragma!panic ();
    }

    /**
     * Generate a field access on a struct value
     * @params:
     *     - context: the context of the generation
     *     - s: the field access to generate
     * */
    def generateStructFieldAccess (self, dmut context : &GenerateVisitor, s : &StructFieldAccessValue)-> tree_t {
        let str = context:.generateValue (s.getStruct ());
        let field = s.getFieldName ();

        let val = c_binding_get_value_operand (str);
        let lst = c_binding_get_list_operand (str);

        let fieldAcc = fieldAccessExprTree (s.getLoc (), val, field);

        c_binding_build_compound (lst, fieldAcc)
    }

    /**
     * Generate a field access on a tuple value
     * @params:
     *     - context: the context of the generation
     *     - t: the field access to generate
     * */
    def generateTupleFieldAccess (self, dmut context : &GenerateVisitor, t : &TupleFieldAccessValue)-> tree_t {
        let tuple = context:.generateValue (t.getTuple ());
        let field = format ("_%", t.getFieldIndex ());

        let val = c_binding_get_value_operand (tuple);
        let lst = c_binding_get_list_operand (tuple);

        let fieldAcc = fieldAccessExprTree (t.getLoc (), val, field);

        c_binding_build_compound (lst, fieldAcc)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =================================        UNARY        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate an unary operator
     * @params:
     *    - context: the context of the generation
     *    - u: the unary operator to generate
     * */
    def generateUnaryOperator (self, dmut context : &GenerateVisitor, u : &UnaryOperatorValue)-> tree_t {
        match u {
            _ => {
                self.generateUnaryBaseOp (alias context, u)
            }
        }
    }

    /**
     * Generate a basic unary operator
     * @params:
     *     - context: the context of the generation
     *     - u: the unary operator to generate
     * */
    def generateUnaryBaseOp (self, dmut context : &GenerateVisitor, u : &UnaryOperatorValue)-> tree_t {
        let val = context:.generateValue (u.getInner ());
        let type = context:.generateType (u.getType ());

        let lval = c_binding_get_value_operand (val);

        let op = unaryExprTree (u.getLoc (), u.getOperator (), type, lval);
        return c_binding_build_compound (c_binding_get_list_operand (val), op);
    }

    /**
     * ================================================================================
     * ================================================================================
     * ================================        BINARY        ==========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Generate an affectation
     * @params:
     *    - context: the context of the generation
     *    - a: the affectation value to generate
     * */
    def generateAffect (self, dmut context : &GenerateVisitor, a : &AffectValue)-> tree_t  {
        let left = context:.generateValue (a.getLeft ());
        let right = context:.generateValue (a.getRight ());

        let dmut list = TreeStatementList::new ();
        list:.append (c_binding_get_list_operand (left));
        list:.append (c_binding_get_list_operand (right));

        let lvalue = c_binding_get_value_operand (left);
        let rvalue = c_binding_get_value_operand (right);

        let affVal = affectExprTree (a.getLoc (), lvalue, rvalue, context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ());
        list:.append (c_binding_get_list_operand (affVal));

        let retVal = c_binding_get_value_operand (affVal);

        return c_binding_build_compound (list.getTree (), retVal);
    }


    /**
     * Generate a binary operator
     * @params:
     *     - context: the context of the generation
     *     - b: the binary operator to generate
     * */
    def generateBinaryOperator (self, dmut context : &GenerateVisitor, b : &BinaryOperatorValue)-> tree_t {
        match b {
            bo : &LogicalBinBoolOperatorValue => {
                self.generateBinaryBoolOp (alias context, bo)
            }
            bSpeInt : &SpecialMathIntOperatorValue => {
                context:.generateValue (bSpeInt.getRealValue ())
            }
            bSpeFloat : &SpecialMathFloatOperatorValue => {
                context:.generateValue (bSpeFloat.getRealValue ())
            }
            _ => {
                self.generateBinaryBaseOp (alias context, b)
            }
        }
    }

    /**
     * Generate a basic binary operator
     * @params:
     *   - context: the context of the generation
     *   - b: the binary operator to generate
     * */
    def generateBinaryBaseOp (self, dmut context : &GenerateVisitor, b : &BinaryOperatorValue)-> tree_t {
        let left = context:.generateValue (b.getLeft ());
        let right = context:.generateValue (b.getRight ());
        let type = context:.generateType (b.getType ());


        let lvalue = c_binding_get_value_operand (left);
        let rvalue = c_binding_get_value_operand (right);

        let bin = binaryExprTree (b.getLoc (), b.getOperator (), type, lvalue, rvalue);

        let dmut list = TreeStatementList::new ();
        list:.append (c_binding_get_list_operand (left));
        list:.append (c_binding_get_list_operand (right));

        return c_binding_build_compound (list.getTree (), bin);
    }

    /**
     * Generate a binary operator on bool operands, it is a special function because for bool '&&' operator, the right operand has to be constructed iif the left operand is true
     * Other operators are generated by 'self.generateBinaryBaseOp'
     * @params:
     *    - context: the context of the generation
     *    - b: the binary operator to generate
     * */
    def generateBinaryBoolOp (self, dmut context : &GenerateVisitor, b : &LogicalBinBoolOperatorValue)-> tree_t {
        let left = context:.generateValue (b.getLeft ());
        let right = context:.generateValue (b.getRight ());
        let type = context:.generateType (b.getType ());

        let dmut list = TreeStatementList::new ();

        let var = varDeclTree (b.getLoc (), format ("_bb(%:%)", b.getLoc ().line (), b.getLoc ().col ()), type);
        c_binding_set_decl_context (var, context:.getCurrentFunctionContext ());

        context:.getStackVarDeclChain ():.append (var);
        list:.append (decl::buildDeclTree (b.getLoc (), types::voidTypeTree (), var)); // let __bb(%:%) : bool;
        list:.append (c_binding_get_list_operand (left)); // list (left);

        let (if_L, if_nL) = if (b.getOperator () == BinaryOperators::DAND) { // left && right => if (left) { right } else { left }
            let dmut if_L = TreeStatementList::new (); // left && right => if (left) { list (right); __bb(%:%) = value (right); }
            if_L:.append (c_binding_get_list_operand (right));
            if_L:.append (affectExprTree (b.getLoc (), var, c_binding_get_value_operand (right),
                                          context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ()));

            let dmut if_nL = TreeStatementList::new (); // left && right => else { __bb(%:%) = false; }
            if_nL:.append (affectExprTree (b.getLoc (), var, expr::buildIntCst (type, 0u64),
                                           context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ()));

            (if_L.getTree (), if_nL.getTree ())
        } else { // left || right => if (left) { true } else { right }
            let dmut if_L = TreeStatementList::new (); // if (left) { __bb(%:%) = true; }
            if_L:.append (affectExprTree (b.getLoc (), var, expr::buildIntCst (type, 1u64),
                                          context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ()));

            let dmut if_nL = TreeStatementList::new (); // left || right => else { list (right); __bb(%:%) = value (right); }
            if_nL:.append (c_binding_get_list_operand (right));
            if_nL:.append (affectExprTree (b.getLoc (), var, c_binding_get_value_operand (right),
                                           context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ()));
            (if_L.getTree (), if_nL.getTree ())
        }

        list:.append (conditionalExprTree (b.getLoc (), context:.getCurrentFunctionContext (), c_binding_get_value_operand (left), if_L, if_nL));

        // list  => if (value (left)) { __bb(%:%) = if_L } else { __bb(%:%) = if_nL };
        // value => __bb(%:%)
        return c_binding_build_compound (list.getTree (), var);
    }


}
