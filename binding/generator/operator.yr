mod binding::generator::operator;


import ymirc::semantic::generator::_;
import ymirc::utils::_;
import ymirc::global::core_;
import ymirc::lexing::word;
import ymirc::syntax::keys;

import binding::tree::_;
import binding::generator::visitor;

import std::collection::vec;
import std::io;



/**
 * This visitor class transform ymirc operators into GCC trees
 * */
pub class GenerateOperatorVisitor {

    /**
     * Create an empty visitor
     * */
    pub self () {}

    /**
     * Transform an operator value into a tree
     * @params:
     *     - context: the context of the generation
     *     - value: the value to generate
     * @returns: a GCC tree
     * */
    pub fn generate (self, dmut context : &GenerateVisitor, value : &OperatorValue)-> tree_t {
        match value {
            a : &AffectValue              => { self.generateAffect (alias context, a) }
            a : &SliceAccessValue         => { self.generateSliceAccess (alias context, a) }
            c : &CallValue                => { self.generateCall (alias context, c) }
            c : &ClassFieldAccessValue    => { self.generateClassFieldAccess (alias context, c) }
            c : &ClosureFieldAccessValue  => { self.generateClosureFieldAccess (alias context, c) }
            c : &CtorCallValue            => { self.generateCtorCall (alias context, c) }
            f : &FuncPtrCallValue         => { self.generateFuncPtrCall (alias context, f) }
            m : &MethodCallValue          => { self.generateMethodCall (alias context, m) }
            n : &NameCallValue            => { self.generateNameCall (alias context, n) }
            s : &SliceCompareValue        => { self.generateSliceCompare (alias context, s) }
            s : &SliceConcatValue         => { self.generateSliceConcat (alias context, s) }
            s : &StructFieldAccessValue   => { self.generateStructFieldAccess (alias context, s) }
            t : &TupleFieldAccessValue    => { self.generateTupleFieldAccess (alias context, t) }
            u : &UnaryOperatorValue       => { self.generateUnaryOperator (alias context, u) }
            b : &BinaryOperatorValue      => { self.generateBinaryOperator (alias context, b) }
            a : &ArrayAccessValue         => { self.generateArrayAccess (alias context, a) }
            _ => {
                eprintln (value::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        CALLS        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate Call value
     * @params:
     *    - context: the context of the generation
     *    - c: the call value to generate
     * */
    fn generateCall (self, dmut context : &GenerateVisitor, c : &CallValue)-> tree_t {
        let mut params : [mut tree_t] = [null ; new (c.getParameters ().len + c.getAddParameters ().len)];
        let dmut pre = TreeStatementList::new ();

        for i, p in c.getParameters () {
            let val = context:.generateValue (p);
            params [i] = c_binding_get_value_operand (val);
            pre:.append (c_binding_get_list_operand (val));
        }

        let j = c.getParameters ().len;
        for i, p in c.getAddParameters () {
            let val = context:.generateValue (p);
            params [i + j] = c_binding_promote (c_binding_get_value_operand (val));
            pre:.append (c_binding_get_list_operand (val));
        }


        let func = context:.generateValue (c.getPrototype ());
        let type = context:.generateType (c.getType ());
        let call = expr::callExprTree (c.getLoc (), type, func, params);

        c_binding_build_compound (pre.getTree (), call)
    }

    /**
     * Generate the call of a class constructor
     * @params:
     *     - context: the context of the generation
     *     - c: the call to generate
     * */
    fn generateCtorCall (self, dmut context : &GenerateVisitor, c : &CtorCallValue)-> tree_t {
        let dmut params = Vec!{tree_t}::new ();
        let dmut pre = TreeStatementList::new ();

        let inst = match c.getCtor ().getInstance () {
            NoneValue () => {
                self.generateAllocateSelf (alias context, c.getLoc (), c.getType ().asOf!{&ClassPtrType} ())
            }
            s : _ => {
                context:.generateValue (s)
            }
        };

        params:.push (c_binding_get_value_operand (inst));
        pre:.append (c_binding_get_list_operand (inst));

        for semVal in c.getParameters () {
            let val = context:.generateValue (semVal);
            pre:.append (c_binding_get_list_operand (val));
            params:.push (c_binding_get_value_operand (val));
        }

        for semVal in c.getAddParameters () {
            let val = context:.generateValue (semVal);
            pre:.append (c_binding_get_list_operand (val));
            params:.push (c_binding_get_value_operand (val));
        }

        let clType = context:.generateType (c.getType ());
        let mut func = context:.generateValue (c.getCtor ().getPrototype ());
        pre:.append (c_binding_get_list_operand (func));
        func = c_binding_get_value_operand (func);
        let call = expr::callExprTree (c.getLoc (), clType, func, params[]);
        pre:.append (call);

        c_binding_build_compound (pre.getTree (), c_binding_get_value_operand (inst))
    }

    /**
     * Generate the call for the allocation of a new class
     * @params:
     *    - context: the context of the validation
     * */
    fn generateAllocateSelf (self, dmut context : &GenerateVisitor, loc : &Word, c : &ClassPtrType)-> tree_t {
        let dmut list = TreeStatementList::new ();
        let type = context:.generateType (c);
        let (decl, var) = context:.getValueVisitor ().generateVarDecl (alias context, loc, format ("_self(%)", loc.line ()), type);

        list:.append (decl);

        let vtable = context:.getTypeVisitor ():.retreiveVtable (alias context, c.getInner ());
        let vtableAddr = expr::addressExprTree (loc, pointerTypeTree (pointerTypeTree (voidTypeTree ())), vtable);
        let mut callVal = expr::callExprTree (loc, type, CoreNames::YRT_ALLOC_CLASS, [vtableAddr]);

        list:.append (c_binding_get_list_operand (callVal));
        callVal = c_binding_get_value_operand (callVal);

        let classValue = context:.getValueVisitor ().generateAffect (alias context, loc, var, callVal);
        list:.append (c_binding_get_list_operand (classValue));
        list:.append (c_binding_get_value_operand (classValue));

        c_binding_build_compound (list.getTree (), var)
    }

    /**
     * Generate a call to a function pointer
     * @params:
     *     - context: the context of the generation
     *     - f: the function pointer to call
     * */
    fn generateFuncPtrCall (self, dmut context : &GenerateVisitor, f : &FuncPtrCallValue)-> tree_t {
        context;
        f;
        __pragma!panic ();
    }

    /**
     * Generate a call to a method
     * @params:
     *     - context: the context of the generation
     *     - m: the method call to generate
     * */
    fn generateMethodCall (self, dmut context : &GenerateVisitor, m : &MethodCallValue)-> tree_t {
        context;
        m;
        __pragma!panic ();
    }

    /**
     * Generate to the call to a function by its name
     * @params:
     *     - context: the context of the generation
     *     - n: the call value to generate
     * */
    fn generateNameCall (self, dmut context : &GenerateVisitor, n : &NameCallValue)-> tree_t {
        context;
        n;
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        SLICES        ===========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Generate a slice comparison value
     * @params:
     *     - context: the context of the generation
     *     - s: the slice compare to generate
     * */
    fn generateSliceCompare (self, dmut context : &GenerateVisitor, s : &SliceCompareValue)-> tree_t {
        context;
        s;
        __pragma!panic ();
    }

    /**
     * Generate a slice concatenation value
     * @params:
     *     - context: the context of the generation
     *     - s: the slice concatenation to generate
     * */
    fn generateSliceConcat (self, dmut context : &GenerateVisitor, s : &SliceConcatValue)-> tree_t {
        context;
        s;
        __pragma!panic ();
    }


    /**
     * Generate a slice access value
     * @params:
     *     - context: the context of the generation
     *     - a: the slice access to generate
     * */
    fn generateSliceAccess (self, dmut context : &GenerateVisitor, a : &SliceAccessValue)-> tree_t {
        let left = context:.generateValue (a.getSlice ());
        let right = context:.generateValue (a.getIndex ());

        let dmut list = TreeStatementList::new ();
        list:.append (c_binding_get_list_operand (left));
        list:.append (c_binding_get_list_operand (right));

        let lvalue = c_binding_get_value_operand (left);
        let rvalue = c_binding_get_value_operand (right);

        let resultT = context:.generateType (a.getType ());
        let size = cast!u64 (c_binding_get_type_size (resultT)); // size = sizeof (typeof (*a.left.ptr))

        let indexT = intTypeTree (0, false);
        let indexV = binaryExprTree (a.getLoc (), BinaryOperators::STAR, indexT, rvalue, buildIntCst (indexT, size)); // a.right * size
        let ptrT = pointerTypeTree (resultT);
        let ptrVoid = pointerTypeTree (voidTypeTree ());

        let data_field = castExprTree (a.getLoc (), ptrVoid, fieldAccessExprTree (a.getLoc (), lvalue, SliceKeys::PTR));
        let finalPtrV = castExprTree (a.getLoc (), ptrT, binaryExprTree (a.getLoc (), BinaryOperators::PLUS, ptrVoid, data_field, indexV)); // a.left.ptr + (a.right * size)

        let finalV = c_binding_unref_pointer (finalPtrV, 0u64); // *(a.left.ptr + (a.right * size))

        c_binding_build_compound (list.getTree (), finalV)
    }


    /**
     * ================================================================================
     * ================================================================================
     * ===============================        FIELDS        ===========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Generate a class field access value
     * @params:
     *    - context: the context of the generation
     *    - c: the field access value to generate
     * */
    fn generateClassFieldAccess (self, dmut context : &GenerateVisitor, c : &ClassFieldAccessValue)-> tree_t {
        let clPtr = context:.generateValue (c.getClassInstance ());

        let list = c_binding_get_list_operand (clPtr);
        let clRef = c_binding_unref_pointer (c_binding_get_value_operand (clPtr), 0u64);

        let fieldAcc = fieldAccessExprTree (c.getLoc (), clRef, c.getFieldName ());

        c_binding_build_compound (list, fieldAcc)

    }

    /**
     * Generate a field access on a closure value
     * @params:
     *     - context: the context of the generation
     *     - c: the closure field access to generate
     * */
    fn generateClosureFieldAccess (self, dmut context : &GenerateVisitor, c : &ClosureFieldAccessValue)-> tree_t {
        context;
        c;
        __pragma!panic ();
    }

    /**
     * Generate a field access on a struct value
     * @params:
     *     - context: the context of the generation
     *     - s: the field access to generate
     * */
    fn generateStructFieldAccess (self, dmut context : &GenerateVisitor, s : &StructFieldAccessValue)-> tree_t {
        let str = context:.generateValue (s.getStruct ());
        let field = s.getFieldName ();

        let val = c_binding_get_value_operand (str);
        let lst = c_binding_get_list_operand (str);

        let fieldAcc = fieldAccessExprTree (s.getLoc (), val, field);

        c_binding_build_compound (lst, fieldAcc)
    }

    /**
     * Generate a field access on a tuple value
     * @params:
     *     - context: the context of the generation
     *     - t: the field access to generate
     * */
    fn generateTupleFieldAccess (self, dmut context : &GenerateVisitor, t : &TupleFieldAccessValue)-> tree_t {
        let tuple = context:.generateValue (t.getTuple ());
        let field = format ("_%", t.getFieldIndex ());

        let val = c_binding_get_value_operand (tuple);
        let lst = c_binding_get_list_operand (tuple);

        let fieldAcc = fieldAccessExprTree (t.getLoc (), val, field);

        c_binding_build_compound (lst, fieldAcc)
    }

    /**
     * ================================================================================
     * ================================================================================
     * =================================        UNARY        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate an unary operator
     * @params:
     *    - context: the context of the generation
     *    - u: the unary operator to generate
     * */
    fn generateUnaryOperator (self, dmut context : &GenerateVisitor, u : &UnaryOperatorValue)-> tree_t {
        match u {
            _ => {
                self.generateUnaryBaseOp (alias context, u)
            }
        }
    }

    /**
     * Generate a basic unary operator
     * @params:
     *     - context: the context of the generation
     *     - u: the unary operator to generate
     * */
    fn generateUnaryBaseOp (self, dmut context : &GenerateVisitor, u : &UnaryOperatorValue)-> tree_t {
        let val = context:.generateValue (u.getInner ());
        let type = context:.generateType (u.getType ());

        let lval = c_binding_get_value_operand (val);

        let op = unaryExprTree (u.getLoc (), u.getOperator (), type, lval);
        return c_binding_build_compound (c_binding_get_list_operand (val), op);
    }

    /**
     * ================================================================================
     * ================================================================================
     * ================================        BINARY        ==========================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Generate an affectation
     * @params:
     *    - context: the context of the generation
     *    - a: the affectation value to generate
     * */
    fn generateAffect (self, dmut context : &GenerateVisitor, a : &AffectValue)-> tree_t  {
        let left = context:.generateValue (a.getLeft ());
        let right = context:.generateValue (a.getRight ());

        let dmut list = TreeStatementList::new ();
        list:.append (c_binding_get_list_operand (left));
        list:.append (c_binding_get_list_operand (right));

        let lvalue = c_binding_get_value_operand (left);
        let rvalue = c_binding_get_value_operand (right);

        let affVal = affectExprTree (a.getLoc (), lvalue, rvalue, context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ());
        list:.append (c_binding_get_list_operand (affVal));

        let retVal = c_binding_get_value_operand (affVal);

        return c_binding_build_compound (list.getTree (), retVal);
    }


    /**
     * Generate a binary operator
     * @params:
     *     - context: the context of the generation
     *     - b: the binary operator to generate
     * */
    fn generateBinaryOperator (self, dmut context : &GenerateVisitor, b : &BinaryOperatorValue)-> tree_t {
        match b {
            bo : &LogicalBinBoolOperatorValue => {
                self.generateBinaryBoolOp (alias context, bo)
            }
            bSpeInt : &SpecialMathIntOperatorValue => {
                context:.generateValue (bSpeInt.getRealValue ())
            }
            bSpeFloat : &SpecialMathFloatOperatorValue => {
                context:.generateValue (bSpeFloat.getRealValue ())
            }
            _ => {
                self.generateBinaryBaseOp (alias context, b)
            }
        }
    }

    /**
     * Generate a basic binary operator
     * @params:
     *   - context: the context of the generation
     *   - b: the binary operator to generate
     * */
    fn generateBinaryBaseOp (self, dmut context : &GenerateVisitor, b : &BinaryOperatorValue)-> tree_t {
        let left = context:.generateValue (b.getLeft ());
        let right = context:.generateValue (b.getRight ());
        let type = context:.generateType (b.getType ());


        let lvalue = c_binding_get_value_operand (left);
        let rvalue = c_binding_get_value_operand (right);

        let bin = binaryExprTree (b.getLoc (), b.getOperator (), type, lvalue, rvalue);

        let dmut list = TreeStatementList::new ();
        list:.append (c_binding_get_list_operand (left));
        list:.append (c_binding_get_list_operand (right));

        return c_binding_build_compound (list.getTree (), bin);
    }

    /**
     * Generate a binary operator on bool operands, it is a special function because for bool '&&' operator, the right operand has to be constructed iif the left operand is true
     * Other operators are generated by 'self.generateBinaryBaseOp'
     * @params:
     *    - context: the context of the generation
     *    - b: the binary operator to generate
     * */
    fn generateBinaryBoolOp (self, dmut context : &GenerateVisitor, b : &LogicalBinBoolOperatorValue)-> tree_t {
        let left = context:.generateValue (b.getLeft ());
        let right = context:.generateValue (b.getRight ());
        let type = context:.generateType (b.getType ());

        let dmut list = TreeStatementList::new ();

        let var = varDeclTree (b.getLoc (), format ("_bb(%:%)", b.getLoc ().line (), b.getLoc ().col ()), type);
        c_binding_set_decl_context (var, context:.getCurrentFunctionContext ());

        context:.getStackVarDeclChain ():.append (var);
        list:.append (decl::buildDeclTree (b.getLoc (), types::voidTypeTree (), var)); // let __bb(%:%) : bool;
        list:.append (c_binding_get_list_operand (left)); // list (left);

        let (if_L, if_nL) = if (b.getOperator () == BinaryOperators::DAND) { // left && right => if (left) { right } else { left }
            let dmut if_L = TreeStatementList::new (); // left && right => if (left) { list (right); __bb(%:%) = value (right); }
            if_L:.append (c_binding_get_list_operand (right));
            if_L:.append (affectExprTree (b.getLoc (), var, c_binding_get_value_operand (right),
                                          context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ()));

            let dmut if_nL = TreeStatementList::new (); // left && right => else { __bb(%:%) = false; }
            if_nL:.append (affectExprTree (b.getLoc (), var, expr::buildIntCst (type, 0u64),
                                           context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ()));

            (if_L.getTree (), if_nL.getTree ())
        } else { // left || right => if (left) { true } else { right }
            let dmut if_L = TreeStatementList::new (); // if (left) { __bb(%:%) = true; }
            if_L:.append (affectExprTree (b.getLoc (), var, expr::buildIntCst (type, 1u64),
                                          context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ()));

            let dmut if_nL = TreeStatementList::new (); // left || right => else { list (right); __bb(%:%) = value (right); }
            if_nL:.append (c_binding_get_list_operand (right));
            if_nL:.append (affectExprTree (b.getLoc (), var, c_binding_get_value_operand (right),
                                           context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ()));
            (if_L.getTree (), if_nL.getTree ())
        }

        list:.append (conditionalExprTree (b.getLoc (), context:.getCurrentFunctionContext (), c_binding_get_value_operand (left), if_L, if_nL));

        // list  => if (value (left)) { __bb(%:%) = if_L } else { __bb(%:%) = if_nL };
        // value => __bb(%:%)
        return c_binding_build_compound (list.getTree (), var);
    }

    /**
     * ================================================================================
     * ================================================================================
     * ================================        ACCESS        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate an arary access operator
     * @params:
     *    - context: the context of the generation
     *    - a: the array access to generate
     * */
    fn generateArrayAccess (self, dmut context : &GenerateVisitor, a : &ArrayAccessValue)-> tree_t {
        let left = context:.generateValue (a.getArray ());
        let right = context:.generateValue (a.getIndex ());

        let dmut list = TreeStatementList::new ();
        list:.append (c_binding_get_list_operand (left));
        list:.append (c_binding_get_list_operand (right));

        let lvalue = c_binding_get_value_operand (left);
        let rvalue = c_binding_get_value_operand (right);

        c_binding_build_compound (list.getTree (),
                                  expr::arrayAccessExprTree (a.getLoc (), lvalue, rvalue))
    }


}
