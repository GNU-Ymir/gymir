mod binding::generator::values;


import ymirc::semantic::generator::_;
import ymirc::utils::_;
import ymirc::lexing::word;

import binding::tree::_;
import binding::generator::visitor;

import std::collection::vec;
import std::io;

/**
 * This visitor class transform ymirc values into GCC trees
 * */
pub class GenerateValueVisitor {

    /**
     * Create an empty visitor
     * */
    pub self () {}

    /**
     * Transform a value into a tree
     * @params:
     *     - context: the context of the generation
     *     - value: the value to generate
     * @returns: a GCC tree
     * */
    pub def generate (self, dmut context : &GenerateVisitor, value : &Value)-> tree_t {
        match value {
            lit : &LiteralValue => { self.generateLiteralValue (alias context, lit) }
            b : &BlockValue => { self.generateBlockValue (alias context, b) }
            _ => {
                eprintln (value::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        SCOPE        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a block of values
     * @params:
     *     - context: the context of the generation
     *     - block: the block to generate
     * */
    pub def generateBlockValue (self, dmut context : &GenerateVisitor, block : &BlockValue)-> tree_t {
        if (block.isSet ()) return self.generateSetValue (alias context, block);

        let dmut outerList = TreeStatementList::new ();

        // The variable containing the result value of the block
        let var = match block.getType () {
            VoidType () => { null }
            NoneType () => { null }
            type : _ => {
                let (vdecl, var) = self.generateVarDecl (alias context,
                                                         block.getLoc (),
                                                         format ("_b(%)", block.getLoc ().line ()),
                                                         context:.generateType (type));
                outerList:.append (vdecl);
                var
            }
        };

        context:.enterBlock (block.getLoc ());
        let dmut innerList = TreeStatementList::new ();
        let mut last : (&Value)? = ((&Value)?)::__err__;

        for val in block.getValues () match last {
            Ok (lst : _) => {
                innerList:.append (self.generate (alias context, lst));
                last = val?;
            }
            _ => {
                last = val?;
            }
        }

        if (var !is null) {
            let value = self.generate (alias context,
                                       __pragma!trusted (last.unwrap ()));

            innerList:.append (c_binding_get_list_operand (value))
                :.append (self.generateAffect (alias context, block.getLoc (), var, c_binding_get_value_operand (value)));

            let (bind, _) = context:.quitBlock (block.getLoc (), innerList.getTree ());
            outerList:.append (bind);

            c_binding_build_compound (outerList.getTree (), var)
        } else {
            match last {
                Ok (lst : _) => {
                    innerList:.append (self.generate (alias context, lst));
                }
            }

            let (bind, _) = context:.quitBlock (block.getLoc (), innerList.getTree ());
            bind
        }
    }

    /**
     * Generate a block of value declared as a set (not really entering a block, but just a list of values)
     * @params:
     *     - context: the context of the generation
     *     - block: the block of values to generate
     * */
    pub def generateSetValue (self, dmut context : &GenerateVisitor, block : &BlockValue)-> tree_t {
        context;
        block;
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * ==============================        STATEMENTS        ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate an affectation
     * */
    def generateAffect (self, dmut context : &GenerateVisitor, loc : &Word, left : tree_t, right : tree_t)-> tree_t {
        expr::affectExprTree (loc, left, right, context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * ==============================        VARIABLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a variable declaration
     * @assume: the context is currently inside a block inside a frame
     * @params:
     *     - context: the context of the generation
     *     - loc: the location of the declaration
     *     - name: the name of the variable to declare
     *     - type: the type of the variable to declare
     * @returns:
     *     - .0: the declaration expression (that should be inserted in the block statement list)
     *     - .1: the variable expression (that can be used for referencing the declared variable)
     * */
    pub def generateVarDecl (self, dmut context : &GenerateVisitor, loc : &Word, name : [c8], type : tree_t)-> (tree_t, tree_t) {
        let var = varDeclTree (loc, name, type);
        c_binding_set_decl_context (var, context:.getCurrentFunctionContext ());
        context:.getStackVarDeclChain ():.append (var);

        let decl = decl::buildDeclTree (loc,
                                        types::voidTypeTree (),
                                        var);
        (decl, var)
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        LITERAL        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a literal value
     * @params:
     *     - context: the context of the generation
     *     - lit: the literal value to generate
     * @returns: the GCC tree containing the value
     * */
    def generateLiteralValue (self, dmut context : &GenerateVisitor, lit : &LiteralValue)-> tree_t {
        match lit {
            arr : &ArrayValue => { self.generateArrayLit (alias context, arr) }
            arr : &ArrayAllocValue => { self.generateArrayAlloc (alias context, arr) }
            b : &BoolValue => { self.generateBoolLit (alias context, b) }
            c : &CharValue => { self.generateCharLit (alias context, c) }
            f : &FloatValue => { self.generateFloatLit (alias context, f) }
            i : &IntValue => { self.generateIntLit (alias context, i) }
            n : &NullValue => { self.generateNullLit (alias context, n) }
            s : &StringValue => { self.generateStringLit (alias context, s) }
            t : &TupleValue => { self.generateTupleLit (alias context, t) }
            _ => {
                eprintln (lit::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Generate an array literal value
     * */
    def generateArrayLit (self, dmut context : &GenerateVisitor, arr : &ArrayValue)-> tree_t {
        let type = context:.generateType (arr.getType ());
        let dmut params = Vec!{tree_t}::new ();
        params:.reserve (arr.getInners ().len);

        for i in arr.getInners () {
            params:.push (self.generate (alias context, i));
        }

        expr::buildConstructorIndexed (type, params[])
    }

    /**
     * Generate an array allocation value
     * */
    def generateArrayAlloc (self, dmut context : &GenerateVisitor, arr : &ArrayAllocValue)-> tree_t {
        arr;
        context;
        __pragma!panic ();
    }

    /**
     * Generate an bool literal value
     * */
    def generateBoolLit (self, dmut _ : &GenerateVisitor, b : &BoolValue)-> tree_t {
        expr::buildIntCst (boolTypeTree (), if (b.isTrue ()) { 1u64 } else { 0u64 })
    }

    /**
     * Generate an char literal value
     * */
    def generateCharLit (self, dmut context : &GenerateVisitor, c : &CharValue)-> tree_t {
        let type = context:.generateType (c.getType ());
        match c.getType ().asOf!{&CharType} ().getSize () {
            8u16 => {
                expr::buildIntCst (type, cast!u64 (c.getUtf8 ()))
            }
            _ => {
                expr::buildIntCst (type, cast!u64 (c.getUtf32 ()))
            }
        }
    }

    /**
     * Generate an float literal value
     * */
    def generateFloatLit (self, dmut context : &GenerateVisitor, f : &FloatValue)-> tree_t {
        let type = context:.generateType (f.getType ());
        match f.getType ().asOf!{&FloatType} ().getSize () {
            32u16 => {
                expr::buildFloatCst (type, f.getF32 ())
            }
            _ => {
                expr::buildFloatCst (type, f.getF64 ())
            }
        }
    }

    /**
     * Generate an int literal value
     * */
    def generateIntLit (self, dmut context : &GenerateVisitor, i : &IntValue)-> tree_t {
        let type = context:.generateType (i.getType ());
        let val = i.getValue ().to!{u64} ();

        expr::buildIntCst (type, val)
    } catch {
        _ => __pragma!panic ();
    }

    /**
     * Generate an null literal value
     * */
    def generateNullLit (self, dmut _ : &GenerateVisitor, _ : &NullValue)-> tree_t {
        let type = pointerTypeTree (voidTypeTree ());
        c_binding_build_pointer_cst_value (type, 0u64)
    }

    /**
     * Generate an string literal value
     * */
    def generateStringLit (self, dmut context : &GenerateVisitor, arr : &StringValue)-> tree_t {
        context;
        arr;
        __pragma!panic ();
    }

    /**
     * Generate an tuple literal value
     * */
    def generateTupleLit (self, dmut context : &GenerateVisitor, arr : &TupleValue)-> tree_t {
        context;
        arr;
        __pragma!panic ();
    }



}
