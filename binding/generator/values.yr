mod binding::generator::values;


import ymirc::semantic::generator::_;
import ymirc::utils::_;
import ymirc::lexing::word;
import ymirc::syntax::keys;


import binding::tree::_;
import binding::generator::visitor;

import std::collection::vec;
import std::collection::map;
import std::io;

/**
 * This visitor class transform ymirc values into GCC trees
 * */
pub class GenerateValueVisitor {


    /**
     * Create an empty visitor
     * */
    pub self () {}

    /**
     * Transform a value into a tree
     * @params:
     *     - context: the context of the generation
     *     - value: the value to generate
     * @returns: a GCC tree
     * */
    pub def generate (self, dmut context : &GenerateVisitor, value : &Value)-> tree_t {
        match value {
            lit : &LiteralValue   => { self.generateLiteral (alias context, lit) }
            ct : &ConstructValue  => { self.generateConstruct (alias context, ct) }
            m : &MemoryValue      => { self.generateMemory (alias context, m) }
            v : &VarDeclValue     => { self.generateVarDecl (alias context, v) }
            v : &VarRefValue      => { self.generateVarRef (alias context, v) }
            o : &OperatorValue    => { context:.getOperatorVisitor ().generate (alias context, o) }
            p : &PrototypeValue   => { self.generatePrototype (alias context, p) }
            sc : &ScopeValue      => { self.generateScope (alias context, sc) }
            r : &ReturnValue      => { self.generateReturn (alias context, r) }
            u : &UniqValue        => { self.generateUniq (alias context, u) }
            n : &NamedValue       => { self.generate (alias context, n.getContent ()) }
            _ => {
                eprintln (value::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        SCOPE        ============================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Generate a scope and flow control value
     * @params:
     *     - context: the context of the validation
     *     - sc: the scope value to generate
     * */
    def generateScope (self, dmut context : &GenerateVisitor, sc : &ScopeValue)-> tree_t {
        match sc {
            b : &BlockValue       => { self.generateBlock (alias context, b) }
            c : &ConditionalValue => { self.generateConditional (alias context, c) }
            l : &LoopValue        => { self.generateLoop (alias context, l) }
            _ => {
                eprintln (sc::typeinfo.name);
                __pragma!panic ();
            }
        }
    }


    /**
     * Generate a block of values
     * @params:
     *     - context: the context of the generation
     *     - block: the block to generate
     * */
    pub def generateBlock (self, dmut context : &GenerateVisitor, block : &BlockValue)-> tree_t {
        if (block.isSet ()) return self.generateSet (alias context, block);

        let dmut outerList = TreeStatementList::new ();

        // The variable containing the result value of the block
        let var = match block.getType () {
            VoidType () => { null }
            NoneType () => { null }
            type : _ => {
                let (vdecl, var) = self.generateVarDecl (alias context,
                                                         block.getLoc (),
                                                         format ("_b(%)", block.getLoc ().line ()),
                                                         context:.generateType (type));
                outerList:.append (vdecl);
                var
            }
        };

        context:.enterBlock (block.getLoc ());
        let dmut innerList = TreeStatementList::new ();
        let mut last : (&Value)? = ((&Value)?)::__err__;

        for val in block.getValues () match last {
            Ok (lst : _) => {
                innerList:.append (self.generate (alias context, lst));
                last = val?;
            }
            _ => {
                last = val?;
            }
        }

        if (var !is null) {
            let value = self.generate (alias context,
                                       __pragma!trusted (last.unwrap ()));

            innerList:.append (c_binding_get_list_operand (value))
                :.append (self.generateAffect (alias context, block.getLoc (), var, c_binding_get_value_operand (value)));

            let (bind, _) = context:.quitBlock (block.getLoc (), innerList.getTree ());
            outerList:.append (bind);

            c_binding_build_compound (outerList.getTree (), var)
        } else {
            match last {
                Ok (lst : _) => {
                    innerList:.append (self.generate (alias context, lst));
                }
            }

            let (bind, _) = context:.quitBlock (block.getLoc (), innerList.getTree ());
            bind
        }
    }

    /**
     * Generate a block of value declared as a set (not really entering a block, but just a list of values)
     * @params:
     *     - context: the context of the generation
     *     - block: the block of values to generate
     * */
    pub def generateSet (self, dmut context : &GenerateVisitor, block : &BlockValue)-> tree_t {
        let dmut list = TreeStatementList::new ();
        let var = match block.getType () {
            VoidType () => { null }
            NoneType () => { null }
            type : _ => {
                let (vdecl, var) = self.generateVarDecl (alias context,
                                                         block.getLoc (),
                                                         format ("_b(%)", block.getLoc ().line ()),
                                                         context:.generateType (type));
                list:.append (vdecl);
                var
            }
        };

        let mut last : (&Value)? = ((&Value)?)::__err__;
        for val in block.getValues () match last {
            Ok (lst : _) => {
                list:.append (self.generate (alias context, lst));
                last = val?;
            }
            _ => {
                last = val?;
            }
        }

        if (var !is null) {
            let value = self.generate (alias context,
                                       __pragma!trusted (last.unwrap ()));

            list:.append (c_binding_get_list_operand (value))
                :.append (self.generateAffect (alias context, block.getLoc (), var, c_binding_get_value_operand (value)));

            c_binding_build_compound (list.getTree (), var)
        } else {
            match last {
                Ok (lst : _) => {
                    list:.append (self.generate (alias context, lst));
                }
            }

            list.getTree ()
        }
    }

    /**
     * Generate a conditional value
     * @params:
     *    - context: the context of the validation
     *    - cond: the conditional to generate
     * */
    pub def generateConditional (self, dmut context : &GenerateVisitor, cond : &ConditionalValue)-> tree_t {
        let dmut all = TreeStatementList::new ();
        let var = match cond.getType () {
            VoidType () => { null }
            NoneType () => { null }
            type : _ => {
                let (vdecl, var) = self.generateVarDecl (alias context,
                                                         cond.getLoc (),
                                                         format ("_c(%)", cond.getLoc ().line ()),
                                                         context:.generateType (type));
                all:.append (vdecl);
                var
            }
        };

        let test = context:.generateValue (cond.getTest ());
        context:.enterBlock (cond.getLoc ());

        let dmut condTree = TreeStatementList::new ();

        let ifContent = if (var !is null && cond.getContent ().getType () == cond.getType ()) {
            let dmut innerList = TreeStatementList::new ();
            let ct = context:.generateValue (cond.getContent ());
            innerList:.append (c_binding_get_list_operand (ct));
            innerList:.append (affectExprTree (cond.getLoc (), var, c_binding_get_value_operand (ct),
                                               context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ()));

            innerList.getTree ()
        } else { context:.generateValue (cond.getContent ()) }

        let elseContent = if (var !is null && cond.getElse ().getType () == cond.getType ()) {
            let dmut innerList = TreeStatementList::new ();
            let ct = context:.generateValue (cond.getElse ());
            innerList:.append (c_binding_get_list_operand (ct));
            innerList:.append (self.generateAffect (alias context, cond.getLoc (), var, c_binding_get_value_operand (ct)));

            innerList.getTree ()
        } else { context:.generateValue (cond.getElse ()) }


        condTree:.append (conditionalExprTree (cond.getLoc (),
                                               context:.getCurrentFunctionContext (),
                                               test, ifContent, elseContent));

        let (bind, _) = context:.quitBlock (cond.getLoc (), condTree.getTree ());
        all:.append (bind);

        if (var !is null) {
            c_binding_build_compound (all.getTree (), var)
        } else {
            all.getTree ()
        }
    }

    /**
     * Generate a loop value
     * @params:
     *    - context: the context of the validation
     *    - l: the loop to generate
     * */
    def generateLoop (self, dmut context : &GenerateVisitor, l : &LoopValue)-> tree_t {
        if (l.isCteFor ()) return self.generateCteForLoop (alias context, l);
        let dmut all = TreeStatementList::new ();
        let var = match l.getType () {
            VoidType () => { null }
            NoneType () => { null }
            type : _ => {
                let (vdecl, var) = self.generateVarDecl (alias context,
                                                         l.getLoc (),
                                                         format ("_c(%)", l.getLoc ().line ()),
                                                         context:.generateType (type));
                all:.append (vdecl);
                var
            }
        };

        let test = context:.generateValue (l.getTest ());
        context:.enterBlock (l.getLoc ());
        let dmut loopTree = TreeStatementList::new ();

        let endLab = decl::labelDeclTree (l.getLoc (), context:.getCurrentFunctionContext (), "end"s8);
        context:.enterLoop (endLab, var);

        let content = if (var !is null && !l.getContent ().isBreaker () && test !is null) {
            let dmut innerList = TreeStatementList::new ();
            let innerContent = context:.generateValue (l.getContent ());
            innerList:.append (c_binding_get_list_operand (innerContent));

            innerList:.append (self.generateAffect (alias context, l.getLoc (), var, c_binding_get_value_operand (innerContent)));
            innerList.getTree ()
        } else {
            context:.generateValue (l.getContent ())
        };

        context:.quitLoop ();

        let begLab = decl::labelDeclTree (l.getLoc (), context:.getCurrentFunctionContext (), "begin"s8);
        let testLab = decl::labelDeclTree (l.getLoc (), context:.getCurrentFunctionContext (), "test"s8);

        if (!l.isDo () && test !is null) {
            loopTree:.append (expr::gotoExprTree (l.getLoc (), testLab));
        }

        loopTree:.append (expr::labelExprTree (l.getLoc (), begLab));
        loopTree:.append (content);
        if (test !is null) {
            loopTree:.append (expr::labelExprTree (l.getLoc (), testLab));
            loopTree:.append (expr::conditionalExprTree (l.getLoc (),
                                                         context:.getCurrentFunctionContext (),
                                                         test,
                                                         expr::gotoExprTree (l.getLoc (), begLab),
                                                         expr::gotoExprTree (l.getLoc (), endLab)));
        } else {
            loopTree:.append (expr::gotoExprTree (l.getLoc (), begLab));
        }

        loopTree:.append (expr::labelExprTree (l.getLoc (), endLab));

        let (binding, _) = context:.quitBlock (l.getLoc (), loopTree.getTree ());
        all:.append (binding);

        if (var !is null) {
            c_binding_build_compound (all.getTree (), var)
        } else {
            all.getTree ()
        }
    }

    /**
     * Generate a cte for loop
     * */
    def generateCteForLoop (self, dmut context : &GenerateVisitor, l : &LoopValue)-> tree_t {
        let dmut all = TreeStatementList::new ();
        let var = match l.getType () {
            VoidType () => { null }
            NoneType () => { null }
            type : _ => {
                let (vdecl, var) = self.generateVarDecl (alias context,
                                                         l.getLoc (),
                                                         format ("_c(%)", l.getLoc ().line ()),
                                                         context:.generateType (type));
                all:.append (vdecl);
                var
            }
        };

        context:.enterBlock (l.getLoc ());
        let dmut loopTree = TreeStatementList::new ();

        let endLab = decl::labelDeclTree (l.getLoc (), context:.getCurrentFunctionContext (), "end"s8);
        context:.enterLoop (endLab, var);

        let content = if (var !is null && !l.getContent ().isBreaker ()) {
            let dmut innerList = TreeStatementList::new ();
            let innerContent = context:.generateValue (l.getContent ());
            innerList:.append (c_binding_get_list_operand (innerContent));

            innerList:.append (self.generateAffect (alias context, l.getLoc (), var, c_binding_get_value_operand (innerContent)));
            innerList.getTree ()
        } else {
            context:.generateValue (l.getContent ())
        };

        context:.quitLoop ();

        loopTree:.append (content);
        loopTree:.append (expr::labelExprTree (l.getLoc (), endLab));

        let (binding, _) = context:.quitBlock (l.getLoc (), loopTree.getTree ());
        all:.append (binding);

        if (var !is null) {
            c_binding_build_compound (all.getTree (), var)
        } else {
            all.getTree ()
        }
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * ==============================        STATEMENTS        ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate an affectation from trees instead of a generator
     * @info: this operation is used for internal affectations, not to generate an AffectValue
     *        that is generated by the GenerateOperatorVisitor
     * */
    def generateAffect (self, dmut context : &GenerateVisitor, loc : &Word, left : tree_t, right : tree_t)-> tree_t {
        expr::affectExprTree (loc, left, right, context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ())
    }

    /**
     * Generate a return value
     * */
    def generateReturn (self, dmut context : &GenerateVisitor, ret : &ReturnValue)-> tree_t {
        match ret.getValue () {
            NoneValue () => returnExprTree (ret.getLoc ())
            UnitValue () => returnExprTree (ret.getLoc ())
            val : _ => {
                let res = c_binding_get_result_decl (context:.getCurrentFunctionContext ());
                returnExprTree (ret.getLoc (), res, context:.generateValue (val))
            }
        }
    }

    /**
     * Generate an uniq value
     * */
    def generateUniq (self, dmut context : &GenerateVisitor, uni : &UniqValue)-> tree_t {
        let varR = context:.getVariable (uni.getValue ().getUniqId ());
        match varR {
            Ok ((_, var : _)) => { return c_binding_to_direct_value (var); }
        };

        let dmut list = TreeStatementList::new ();
        let type = pointerTypeTree (context:.generateType (uni.getValue ().getType ()));
        let name = format ("uniq_%", uni.getValue ().getUniqId ());
        let var = self.generateRootVarDecl (alias context, uni.getLoc (), uni.getValue ().getUniqId (), name, type);

        let valueC = context:.generateValue (uni.getValue ());
        list:.append (c_binding_get_list_operand (valueC));

        let value = c_binding_get_value_operand (valueC);
        if (c_binding_is_variable (value)) {
            let uniqContentAddr = expr::addressExprTree (uni.getLoc (), type, value);
            list:.append (self.generateAffect (alias context, uni.getLoc (), var, uniqContentAddr));
        } else {
            let typeContent = context:.generateType (uni.getValue ().getType ());
            let nameContent = format ("uniq_c_%", uni.getValue ().getUniqId ());
            let varContent  = self.generateRootVarDecl (alias context, uni.getLoc (), uni.getValue ().getUniqId (), nameContent, typeContent, insertVarRef-> false);

            list:.append (self.generateAffect (alias context, uni.getLoc (), varContent, value));

            let uniqContentAddr = expr::addressExprTree (uni.getLoc (), type, varContent);
            list:.append (self.generateAffect (alias context, uni.getLoc (), var, uniqContentAddr));
        }

        c_binding_build_compound (list.getTree (), c_binding_to_direct_value (var))
    }
    
    /**
     * ================================================================================
     * ================================================================================
     * ==============================        VARIABLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a variable declaration
     * @assume: the context is currently inside a block inside a frame
     * @params:
     *     - context: the context of the generation
     *     - loc: the location of the declaration
     *     - name: the name of the variable to declare
     *     - type: the type of the variable to declare
     * @returns:
     *     - .0: the declaration expression (that should be inserted in the block statement list)
     *     - .1: the variable expression (that can be used for referencing the declared variable)
     * */
    pub def generateVarDecl (self, dmut context : &GenerateVisitor, loc : &Word, name : [c8], type : tree_t)-> (tree_t, tree_t) {
        let var = varDeclTree (loc, name, type);
        c_binding_set_decl_context (var, context:.getCurrentFunctionContext ());
        context:.getStackVarDeclChain ():.append (var);

        let decl = decl::buildDeclTree (loc,
                                        types::voidTypeTree (),
                                        var);
        (decl, var)
    }

    /**
     * Generate a variable declaration accessible anywhere in the frame
     *      * @params:
     *     - context: the context of the generation
     *     - loc: the location of the declaration
     *     - name: the name of the variable to declare
     *     - type: the type of the variable to declare
     * @returns:
     *     - .0: the declaration expression (that should be inserted in the block statement list)
     *     - .1: the variable expression (that can be used for referencing the declared variable)
     * */
    def generateRootVarDecl (self, dmut context : &GenerateVisitor, loc : &Word, id : usize, name : [c8], type : tree_t, insertVarRef : bool = true)-> tree_t {
        let var = varDeclTree (loc, name, type);

        c_binding_set_decl_context (var, context:.getCurrentFunctionContext ());
        context:.getRootStackVarDeclChain ():.append (var);

        let decl = decl::buildDeclTree (loc, types::voidTypeTree (), var);
        context:.getRootExprList ():.append (decl);
        if (insertVarRef) {
            context:.insertVariable (id, var, false);
        }

        var
    }


    /**
     * Generate a variable declaration
     * */
    def generateVarDecl (self, dmut context : &GenerateVisitor, v : &VarDeclValue)-> tree_t {
        match v.getType () {
            LambdaType () => { return null; }
            TemporaryType () => { return null; }
        }

        let type = context:.generateType (v.getVarType ());
        let var = varDeclTree (v.getLoc (), v.getLoc ().str (), type);

        c_binding_set_decl_context (var, context:.getCurrentFunctionContext ());
        context:.getStackVarDeclChain ():.append (var);
        context:.insertVariable (v.getUniqId (), var, false);

        match v.getValue () {
            NoneValue () => {
                decl::buildDeclTree (v.getLoc (), voidTypeTree (), var)
            }
            val : _ => {
                let value = self.generate (alias context, val);
                let dmut list = TreeStatementList::new ();
                list:.append (c_binding_get_list_operand (value))
                    :.append (affectExprTree (v.getLoc (), var, c_binding_get_value_operand (value),
                                              context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ()));

                c_binding_build_compound (list.getTree (), decl::buildDeclTree (v.getLoc (), voidTypeTree (), var))
            }
        }
    }

    /**
     * Generate a variable reference value
     * */
    def generateVarRef (self, dmut context : &GenerateVisitor, v : &VarRefValue)-> tree_t {
        match context:.getVariable (v.getRefId ()) {
            Ok (x : _) => {
                if (x._0) { // should be the same as v.isReference ()
                    c_binding_to_direct_value (x._1)
                } else {
                    x._1
                }
            }
            _ => {
                eprintln ("Malformed variable : ", v);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ================================        MEMORY        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a memory operation value
     * @params:
     *     - context: the context of the generation
     *     - mem: the memory value to generate
     * @returns: the GCC tree containing the memory operation
     * */
    def generateMemory (self, dmut context : &GenerateVisitor, mem : &MemoryValue)-> tree_t {
        match mem {
            a : &AddressValue     => { self.generateAddress (alias context, a) }
            a : &AliaserValue     => { self.generateAliaser (alias context, a) }
            c : &CopierValue      => { self.generateCopier (alias context, c) }
            d : &DeepCopierValue  => { self.generateDeepCopier (alias context, d) }
            r : &ReferencerValue  => { self.generateReferencer (alias context, r) }
            s : &SliceValue       => { self.generateSliceMem (alias context, s) }
            _ => {
                eprintln (mem::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Generate a address operation
     * */
    def generateAddress (self, dmut context : &GenerateVisitor, a : &AddressValue)-> tree_t {
        let type = context:.generateType (a.getType ());
        let value = context:.generateValue (a.getInner ());

        let valType = c_binding_get_type (value);

        // sometimes AddressValue are used on already constructed addresses (references, string literals, ...)
        // So if we get a pointer value that has the same depth, meaning pointer of pointer of ...
        // Then we can assume it is already constructed, and can be returned as it is, with a cast though
        if (c_binding_get_pointer_depth (valType) == c_binding_get_pointer_depth (type)) {
            expr::castExprTree (a.getLoc (), type, value)
        } else {
            let dmut lst = TreeStatementList::new ();
            lst:.append (c_binding_get_list_operand (value));

            let addr = expr::addressExprTree (a.getLoc (), type, c_binding_get_value_operand (value));

            c_binding_build_compound (lst.getTree (), addr)
        }
    }

    /**
     * Generate an aliaser value
     * */
    def generateAliaser (self, dmut context : &GenerateVisitor, a : &AliaserValue)-> tree_t {
        context;
        a;
        __pragma!panic ();
    }

    /**
     * Generate a copy value
     * */
    def generateCopier (self, dmut context : &GenerateVisitor, c : &CopierValue)-> tree_t {
        context;
        c;
        __pragma!panic ();
    }

    /**
     * Generate a deep copy value
     * */
    def generateDeepCopier (self, dmut context : &GenerateVisitor, d : &DeepCopierValue)-> tree_t {
        context;
        d;
        __pragma!panic ();
    }

    /**
     * Generate a referencer value
     * */
    def generateReferencer (self, dmut context : &GenerateVisitor, r : &ReferencerValue)-> tree_t {
        context;
        r;
        __pragma!panic ();
    }

    /**
     * Generate an aliaser to a slice value
     * */
    def generateSliceMem (self, dmut context : &GenerateVisitor, s : &SliceValue)-> tree_t {
        let val = self.generate (alias context, s.getInner ());
        let type = context:.generateType (s.getType ());
        match s.getInner () {
            str : &StringValue => {
                let size = buildIntCst (intTypeTree (0, false), cast!{u64} (str.getLen ()));
                expr::buildConstructorFields (type, [size, val], [SliceKeys::LEN, SliceKeys::PTR])
            }
            a : &ArrayValue => {
                let size = buildIntCst (intTypeTree (0, false), cast!{u64} (a.getLen ()));
                expr::buildConstructorFields (type, [size, val], [SliceKeys::LEN, SliceKeys::PTR])
            }
            SliceCtorValue () => {
                val
            }
            _ => {
                eprintln ((s.getInner ())::typeinfo.name);
                __pragma!panic ();
            }
        }
    }


    /**
     * ================================================================================
     * ================================================================================
     * ================================        PROTOS        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a prototype value
     * @params:
     *    - context: the context of the generation
     *    - proto: the prototype to generate
     * */
    def generatePrototype (self, dmut context : &GenerateVisitor, proto : &PrototypeValue)-> tree_t {
        let asmName = context:.getMangler ().manglePrototype (proto);

        let mut params : [mut tree_t] = [null ; new proto.getParameters ().len];
        for i, p in proto.getParameters () {
            let type = if p.isReference () {
                pointerTypeTree (context:.generateType (p.getType ()))
            } else {
                context:.generateType (p.getType ())
            };

            params [i] = type;
        }

        let retType = context:.generateType (proto.getRetType ());
        let addrProto = expr::funcPtrExprTree (proto.getLoc (), asmName, retType, params);

        addrProto
    }


    /**
     * ================================================================================
     * ================================================================================
     * ================================        CTORS        ===========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a construct value
     * @params:
     *     - context: the context of the generation
     *     - val: the value to generate
     * @returns: the GCC tree containing the value
     * */
    def generateConstruct (self, dmut context : &GenerateVisitor, val : &ConstructValue)-> tree_t {
        match val {
            c : &CastValue            => { self.generateCast (alias context, c) }
            c : &CtorDelegateValue    => { self.generateCtorDelegate (alias context, c) }
            d : &DelegateValue        => { self.generateDelegate (alias context, d) }
            f : &FuncPtrValue         => { self.generateFuncPtr (alias context, f) }
            m : &MethodDelegateValue  => { self.generateMethodDelegate (alias context, m) }
            r : &RangeValue           => { self.generateRange (alias context, r) }
            s : &SliceCtorValue       => { self.generateSliceCtor (alias context, s) }
            _ => {
                eprintln (val::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Generate a cast value
     * */
    def generateCast (self, dmut context : &GenerateVisitor, c : &CastValue)-> tree_t {
        let type = context:.generateType (c.getType ());
        let val  = context:.generateValue (c.getContent ());

        castExprTree (c.getLoc (), type, val)
    }

    /**
     * Generate the tree value reprensenting a class ctor delegate
     * */
    def generateCtorDelegate (self, dmut context : &GenerateVisitor, c : &CtorDelegateValue)-> tree_t {
        context;
        c;
        __pragma!panic ();
    }

    /**
     * Generate the tree value reprensenting a function delegate
     * */
    def generateDelegate (self, dmut context : &GenerateVisitor, d : &DelegateValue)-> tree_t {
        context;
        d;
        __pragma!panic ();
    }

    /**
     * Generate the tree value reprensenting a function pointer
     * */
    def generateFuncPtr (self, dmut context : &GenerateVisitor, f : &FuncPtrValue)-> tree_t {
        context;
        f;
        __pragma!panic ();
    }

    /**
     * Generate the tree value reprensenting a class method delegate
     * */
    def generateMethodDelegate (self, dmut context : &GenerateVisitor, m : &MethodDelegateValue)-> tree_t {
        context;
        m;
        __pragma!panic ();
    }

    /**
     * Generate the tree value reprensenting a range value
     * */
    def generateRange (self, dmut context : &GenerateVisitor, r : &RangeValue)-> tree_t {
        let type = context:.generateType (r.getType ());
        let fst = context:.generateValue (r.getLeft ());
        let scd = context:.generateValue (r.getRight ());
        let step = context:.generateValue (r.getStep ());
        let contain = context:.generateValue (r.getIsFull ());

        let dmut list = TreeStatementList::new ();
        list:.append (c_binding_get_list_operand (fst));
        list:.append (c_binding_get_list_operand (scd));
        list:.append (c_binding_get_list_operand (step));
        list:.append (c_binding_get_list_operand (contain));

        let innerType = context:.generateType (r.getType ().asOf!{&RangeType} ().getInners ()[0]);

        let value = buildConstructorFields (type,
                                            [
                                                c_binding_convert (innerType, c_binding_get_value_operand (fst)),
                                                c_binding_convert (innerType, c_binding_get_value_operand (scd)),
                                                c_binding_get_value_operand (step),
                                                c_binding_get_value_operand (contain)],
                                            [RangeKeys::FST, RangeKeys::SCD, RangeKeys::STEP, RangeKeys::CONTAIN]);

        c_binding_build_compound (list.getTree (), value)
    }

    /**
     * Generate the tree value reprensenting a slice value ctor
     * */
    def generateSliceCtor (self, dmut context : &GenerateVisitor, s : &SliceCtorValue)-> tree_t {
        context;
        s;
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        LITERAL        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a literal value
     * @params:
     *     - context: the context of the generation
     *     - lit: the literal value to generate
     * @returns: the GCC tree containing the value
     * */
    def generateLiteral (self, dmut context : &GenerateVisitor, lit : &LiteralValue)-> tree_t {
        match lit {
            arr : &ArrayValue       => { self.generateArrayLit (alias context, arr) }
            arr : &ArrayAllocValue  => { self.generateArrayAlloc (alias context, arr) }
            b : &BoolValue          => { self.generateBoolLit (alias context, b) }
            c : &CharValue          => { self.generateCharLit (alias context, c) }
            f : &FloatValue         => { self.generateFloatLit (alias context, f) }
            i : &IntValue           => { self.generateIntLit (alias context, i) }
            n : &NullValue          => { self.generateNullLit (alias context, n) }
            s : &StringValue        => { self.generateStringLit (alias context, s) }
            t : &TupleValue         => { self.generateTupleLit (alias context, t) }
            UnitValue ()            => { null }
            NoneValue ()            => { null }
            _ => {
                eprintln (lit::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Generate an array literal value
     * */
    def generateArrayLit (self, dmut context : &GenerateVisitor, arr : &ArrayValue)-> tree_t {
        let type = context:.generateType (arr.getType ());

        let dmut list = TreeStatementList::new ();
        let dmut params = Vec!{tree_t}::new ();
        params:.reserve (arr.getInners ().len);

        for i in arr.getInners () {
            let p = self.generate (alias context, i);
            list:.append (c_binding_get_list_operand (p));
            params:.push (c_binding_get_value_operand (p));
        }

        let value = expr::buildConstructorIndexed (type, params[]);

        c_binding_build_compound (list.getTree (), value)
    }

    /**
     * Generate an array allocation value
     * */
    def generateArrayAlloc (self, dmut context : &GenerateVisitor, arr : &ArrayAllocValue)-> tree_t {
        arr;
        context;
        __pragma!panic ();
    }

    /**
     * Generate an bool literal value
     * */
    def generateBoolLit (self, dmut _ : &GenerateVisitor, b : &BoolValue)-> tree_t {
        expr::buildIntCst (boolTypeTree (), if (b.isTrue ()) { 1u64 } else { 0u64 })
    }

    /**
     * Generate an char literal value
     * */
    def generateCharLit (self, dmut context : &GenerateVisitor, c : &CharValue)-> tree_t {
        let type = context:.generateType (c.getType ());
        match c.getType ().asOf!{&CharType} ().getSize () {
            8u16 => {
                expr::buildIntCst (type, cast!u64 (c.getValue ().utf8))
            }
            16u16 => {
                expr::buildIntCst (type, cast!u64 (c.getValue ().utf16))
            }
            _ => {
                expr::buildIntCst (type, cast!u64 (c.getValue ().utf32))
            }
        }
    }

    /**
     * Generate an float literal value
     * */
    def generateFloatLit (self, dmut context : &GenerateVisitor, f : &FloatValue)-> tree_t {
        let type = context:.generateType (f.getType ());
        if (f.getValue ().isNan ()) {
            return expr::buildNanCst (type);
        } else if (f.getValue ().isPositiveInf ()) {
            return expr::buildInfPosCst (type);
        } else if (f.getValue ().isNegativeInf ()) {
            return expr::buildInfNegCst (type);
        }

        let val = f.getValue ().toHexString ();
        expr::buildFloatCst (type, val)
    }

    /**
     * Generate an int literal value
     * */
    def generateIntLit (self, dmut context : &GenerateVisitor, i : &IntValue)-> tree_t {
        let type = context:.generateType (i.getType ());
        match i.getType () {
            t : &IntType => {
                match t.isSigned () {
                    true => {
                        let val = i.getValue ().to!{i64} ();
                        expr::buildIntCst (type, val)
                    }
                    _ => {
                        let val = i.getValue ().to!{u64} ();
                        expr::buildIntCst (type, val)
                    }
                }
            }
            _ => __pragma!panic ();
        }
    } catch {
        _ => {
            __pragma!panic ();
        }
    }

    /**
     * Generate an null literal value
     * */
    def generateNullLit (self, dmut _ : &GenerateVisitor, _ : &NullValue)-> tree_t {
        let type = pointerTypeTree (voidTypeTree ());
        c_binding_build_pointer_cst_value (type, 0u64)
    }

    /**
     * Generate an string literal value
     * */
    def generateStringLit (self, dmut _ : &GenerateVisitor, str : &StringValue)-> tree_t {
        import ymirc::semantic::validator::utf;

        match str.getEncodingSize () {
            8u16 => {
                let encoded = (str.getValue ().utf8 ~ [0u8]);
                c_binding_build_string_literal (cast!u64 (encoded.len), encoded.ptr)
            }
            16u16 => {
                let encoded = (str.getValue ().utf16 ~ [0u16]);
                c_binding_build_string_literal (cast!u64 (encoded.len * 2us), encoded.ptr)
            }
            _ => {
                let encoded = (str.getValue ().utf32 ~ [0u32]);
                c_binding_build_string_literal (cast!u64 (encoded.len * 4us), encoded.ptr)
            }
        }
    }

    /**
     * Generate an tuple literal value
     * */
    def generateTupleLit (self, dmut context : &GenerateVisitor, arr : &TupleValue)-> tree_t {
        let type = context:.generateType (arr.getType ());
        let dmut list = TreeStatementList::new ();
        let mut inners : [mut tree_t] = [null ; new arr.getInners ().len];

        for i, t in arr.getInners () {
            let p = context:.generateValue (t);
            list:.append (c_binding_get_list_operand (p));
            inners [i] = c_binding_get_value_operand (p);
        }

        let value = buildConstructorFields (type, inners, []);

        c_binding_build_compound (list.getTree (), value)
    }



}
