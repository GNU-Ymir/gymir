mod binding::generator::values;


import ymirc::semantic::generator::_;
import ymirc::utils::_;
import ymirc::lexing::word;

import binding::tree::_;
import binding::generator::visitor;

import std::collection::vec;
import std::io;

/**
 * This visitor class transform ymirc values into GCC trees
 * */
pub class GenerateValueVisitor {

    /**
     * Create an empty visitor
     * */
    pub self () {}

    /**
     * Transform a value into a tree
     * @params:
     *     - context: the context of the generation
     *     - value: the value to generate
     * @returns: a GCC tree
     * */
    pub def generate (self, dmut context : &GenerateVisitor, value : &Value)-> tree_t {
        match value {
            lit : &LiteralValue   => { self.generateLiteral (alias context, lit) }
            ct : &ConstructValue  => { self.generateConstruct (alias context, ct) }
            b : &BlockValue       => { self.generateBlock (alias context, b) }
            m : &MemoryValue      => { self.generateMemory (alias context, m) }
            _ => {
                eprintln (value::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        SCOPE        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a block of values
     * @params:
     *     - context: the context of the generation
     *     - block: the block to generate
     * */
    pub def generateBlock (self, dmut context : &GenerateVisitor, block : &BlockValue)-> tree_t {
        if (block.isSet ()) return self.generateSet (alias context, block);

        let dmut outerList = TreeStatementList::new ();

        // The variable containing the result value of the block
        let var = match block.getType () {
            VoidType () => { null }
            NoneType () => { null }
            type : _ => {
                let (vdecl, var) = self.generateVarDecl (alias context,
                                                         block.getLoc (),
                                                         format ("_b(%)", block.getLoc ().line ()),
                                                         context:.generateType (type));
                outerList:.append (vdecl);
                var
            }
        };

        context:.enterBlock (block.getLoc ());
        let dmut innerList = TreeStatementList::new ();
        let mut last : (&Value)? = ((&Value)?)::__err__;

        for val in block.getValues () match last {
            Ok (lst : _) => {
                innerList:.append (self.generate (alias context, lst));
                last = val?;
            }
            _ => {
                last = val?;
            }
        }

        if (var !is null) {
            let value = self.generate (alias context,
                                       __pragma!trusted (last.unwrap ()));

            innerList:.append (c_binding_get_list_operand (value))
                :.append (self.generateAffect (alias context, block.getLoc (), var, c_binding_get_value_operand (value)));

            let (bind, _) = context:.quitBlock (block.getLoc (), innerList.getTree ());
            outerList:.append (bind);

            c_binding_build_compound (outerList.getTree (), var)
        } else {
            match last {
                Ok (lst : _) => {
                    innerList:.append (self.generate (alias context, lst));
                }
            }

            let (bind, _) = context:.quitBlock (block.getLoc (), innerList.getTree ());
            bind
        }
    }

    /**
     * Generate a block of value declared as a set (not really entering a block, but just a list of values)
     * @params:
     *     - context: the context of the generation
     *     - block: the block of values to generate
     * */
    pub def generateSet (self, dmut context : &GenerateVisitor, block : &BlockValue)-> tree_t {
        context;
        block;
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * ==============================        STATEMENTS        ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate an affectation
     * */
    def generateAffect (self, dmut context : &GenerateVisitor, loc : &Word, left : tree_t, right : tree_t)-> tree_t {
        expr::affectExprTree (loc, left, right, context:.getStackVarDeclChain (), context:.getCurrentFunctionContext ())
    }

    /**
     * ================================================================================
     * ================================================================================
     * ==============================        VARIABLES        =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a variable declaration
     * @assume: the context is currently inside a block inside a frame
     * @params:
     *     - context: the context of the generation
     *     - loc: the location of the declaration
     *     - name: the name of the variable to declare
     *     - type: the type of the variable to declare
     * @returns:
     *     - .0: the declaration expression (that should be inserted in the block statement list)
     *     - .1: the variable expression (that can be used for referencing the declared variable)
     * */
    pub def generateVarDecl (self, dmut context : &GenerateVisitor, loc : &Word, name : [c8], type : tree_t)-> (tree_t, tree_t) {
        let var = varDeclTree (loc, name, type);
        c_binding_set_decl_context (var, context:.getCurrentFunctionContext ());
        context:.getStackVarDeclChain ():.append (var);

        let decl = decl::buildDeclTree (loc,
                                        types::voidTypeTree (),
                                        var);
        (decl, var)
    }

    /**
     * ================================================================================
     * ================================================================================
     * ================================        MEMORY        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a memory operation value
     * @params:
     *     - context: the context of the generation
     *     - mem: the memory value to generate
     * @returns: the GCC tree containing the memory operation
     * */
    def generateMemory (self, dmut context : &GenerateVisitor, mem : &MemoryValue)-> tree_t {
        match mem {
            a : &AddressValue     => { self.generateAddress (alias context, a) }
            a : &AliaserValue     => { self.generateAliaser (alias context, a) }
            c : &CopierValue      => { self.generateCopier (alias context, c) }
            d : &DeepCopierValue  => { self.generateDeepCopier (alias context, d) }
            r : &ReferencerValue  => { self.generateReferencer (alias context, r) }
            s : &SliceValue       => { self.generateSliceMem (alias context, s) }
            _ => {
                eprintln (mem::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Generate a address operation
     * */
    def generateAddress (self, dmut context : &GenerateVisitor, a : &AddressValue)-> tree_t {
        context;
        a;
        __pragma!panic ();
    }

    /**
     * Generate an aliaser value
     * */
    def generateAliaser (self, dmut context : &GenerateVisitor, a : &AliaserValue)-> tree_t {
        context;
        a;
        __pragma!panic ();
    }

    /**
     * Generate a copy value
     * */
    def generateCopier (self, dmut context : &GenerateVisitor, c : &CopierValue)-> tree_t {
        context;
        c;
        __pragma!panic ();
    }

    /**
     * Generate a deep copy value
     * */
    def generateDeepCopier (self, dmut context : &GenerateVisitor, d : &DeepCopierValue)-> tree_t {
        context;
        d;
        __pragma!panic ();
    }

    /**
     * Generate a referencer value
     * */
    def generateReferencer (self, dmut context : &GenerateVisitor, r : &ReferencerValue)-> tree_t {
        context;
        r;
        __pragma!panic ();
    }

    /**
     * Generate an aliaser to a slice value
     * */
    def generateSliceMem (self, dmut context : &GenerateVisitor, s : &SliceValue)-> tree_t {
        context;
        s;
        __pragma!panic ();
    }


    /**
     * ================================================================================
     * ================================================================================
     * ================================        CTORS        ===========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a construct value
     * @params:
     *     - context: the context of the generation
     *     - val: the value to generate
     * @returns: the GCC tree containing the value
     * */
    def generateConstruct (self, dmut context : &GenerateVisitor, val : &ConstructValue)-> tree_t {
        match val {
            c : &CastValue            => { self.generateCast (alias context, c) }
            c : &CtorDelegateValue    => { self.generateCtorDelegate (alias context, c) }
            d : &DelegateValue        => { self.generateDelegate (alias context, d) }
            f : &FuncPtrValue         => { self.generateFuncPtr (alias context, f) }
            m : &MethodDelegateValue  => { self.generateMethodDelegate (alias context, m) }
            r : &RangeValue           => { self.generateRange (alias context, r) }
            s : &SliceCtorValue       => { self.generateSliceCtor (alias context, s) }
            _ => {
                eprintln (val::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Generate a cast value
     * */
    def generateCast (self, dmut context : &GenerateVisitor, c : &CastValue)-> tree_t {
        context;
        c;
        __pragma!panic ();
    }

    /**
     * Generate the tree value reprensenting a class ctor delegate
     * */
    def generateCtorDelegate (self, dmut context : &GenerateVisitor, c : &CtorDelegateValue)-> tree_t {
        context;
        c;
        __pragma!panic ();
    }

    /**
     * Generate the tree value reprensenting a function delegate
     * */
    def generateDelegate (self, dmut context : &GenerateVisitor, d : &DelegateValue)-> tree_t {
        context;
        d;
        __pragma!panic ();
    }

    /**
     * Generate the tree value reprensenting a function pointer
     * */
    def generateFuncPtr (self, dmut context : &GenerateVisitor, f : &FuncPtrValue)-> tree_t {
        context;
        f;
        __pragma!panic ();
    }

    /**
     * Generate the tree value reprensenting a class method delegate
     * */
    def generateMethodDelegate (self, dmut context : &GenerateVisitor, m : &MethodDelegateValue)-> tree_t {
        context;
        m;
        __pragma!panic ();
    }

    /**
     * Generate the tree value reprensenting a range value
     * */
    def generateRange (self, dmut context : &GenerateVisitor, r : &RangeValue)-> tree_t {
        context;
        r;
        __pragma!panic ();
    }

    /**
     * Generate the tree value reprensenting a slice value ctor
     * */
    def generateSliceCtor (self, dmut context : &GenerateVisitor, s : &SliceCtorValue)-> tree_t {
        println (s.getPointer (), " ", s.getLen ());
        context;
        s;
        __pragma!panic ();
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================        LITERAL        ==========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a literal value
     * @params:
     *     - context: the context of the generation
     *     - lit: the literal value to generate
     * @returns: the GCC tree containing the value
     * */
    def generateLiteral (self, dmut context : &GenerateVisitor, lit : &LiteralValue)-> tree_t {
        match lit {
            arr : &ArrayValue       => { self.generateArrayLit (alias context, arr) }
            arr : &ArrayAllocValue  => { self.generateArrayAlloc (alias context, arr) }
            b : &BoolValue          => { self.generateBoolLit (alias context, b) }
            c : &CharValue          => { self.generateCharLit (alias context, c) }
            f : &FloatValue         => { self.generateFloatLit (alias context, f) }
            i : &IntValue           => { self.generateIntLit (alias context, i) }
            n : &NullValue          => { self.generateNullLit (alias context, n) }
            s : &StringValue        => { self.generateStringLit (alias context, s) }
            t : &TupleValue         => { self.generateTupleLit (alias context, t) }
            _ => {
                eprintln (lit::typeinfo.name);
                __pragma!panic ();
            }
        }
    }

    /**
     * Generate an array literal value
     * */
    def generateArrayLit (self, dmut context : &GenerateVisitor, arr : &ArrayValue)-> tree_t {
        let type = context:.generateType (arr.getType ());
        let dmut params = Vec!{tree_t}::new ();
        params:.reserve (arr.getInners ().len);

        for i in arr.getInners () {
            params:.push (self.generate (alias context, i));
        }

        expr::buildConstructorIndexed (type, params[])
    }

    /**
     * Generate an array allocation value
     * */
    def generateArrayAlloc (self, dmut context : &GenerateVisitor, arr : &ArrayAllocValue)-> tree_t {
        arr;
        context;
        __pragma!panic ();
    }

    /**
     * Generate an bool literal value
     * */
    def generateBoolLit (self, dmut _ : &GenerateVisitor, b : &BoolValue)-> tree_t {
        expr::buildIntCst (boolTypeTree (), if (b.isTrue ()) { 1u64 } else { 0u64 })
    }

    /**
     * Generate an char literal value
     * */
    def generateCharLit (self, dmut context : &GenerateVisitor, c : &CharValue)-> tree_t {
        let type = context:.generateType (c.getType ());
        match c.getType ().asOf!{&CharType} ().getSize () {
            8u16 => {
                expr::buildIntCst (type, cast!u64 (c.getUtf8 ()))
            }
            _ => {
                expr::buildIntCst (type, cast!u64 (c.getUtf32 ()))
            }
        }
    }

    /**
     * Generate an float literal value
     * */
    def generateFloatLit (self, dmut context : &GenerateVisitor, f : &FloatValue)-> tree_t {
        let type = context:.generateType (f.getType ());
        match f.getType ().asOf!{&FloatType} ().getSize () {
            32u16 => {
                expr::buildFloatCst (type, f.getF32 ())
            }
            _ => {
                expr::buildFloatCst (type, f.getF64 ())
            }
        }
    }

    /**
     * Generate an int literal value
     * */
    def generateIntLit (self, dmut context : &GenerateVisitor, i : &IntValue)-> tree_t {
        let type = context:.generateType (i.getType ());
        let val = i.getValue ().to!{u64} ();

        expr::buildIntCst (type, val)
    } catch {
        _ => __pragma!panic ();
    }

    /**
     * Generate an null literal value
     * */
    def generateNullLit (self, dmut _ : &GenerateVisitor, _ : &NullValue)-> tree_t {
        let type = pointerTypeTree (voidTypeTree ());
        c_binding_build_pointer_cst_value (type, 0u64)
    }

    /**
     * Generate an string literal value
     * */
    def generateStringLit (self, dmut context : &GenerateVisitor, str : &StringValue)-> tree_t {
        println (str.getType ());
        context;
        __pragma!panic ();
    }

    /**
     * Generate an tuple literal value
     * */
    def generateTupleLit (self, dmut context : &GenerateVisitor, arr : &TupleValue)-> tree_t {
        context;
        arr;
        __pragma!panic ();
    }



}
