mod binding::generator::visitor;

import binding::generator::types;
import binding::generator::values;
import binding::generator::operator;

import ymirc::semantic::generator::mangler;
import ymirc::semantic::generator::_;
import ymirc::global::state;
import ymirc::global::core_;
import ymirc::syntax::keys;

import ymirc::utils::_;
import ymirc::lexing::word;

import binding::tree::_;

import std::collection::vec;
import std::collection::map;
import std::collection::set;
import std::io;


/**
 * This generator class transform ymirc objects into GCC trees
 */
pub class GenerateVisitor {

    /**
     * ================================================================================
     * ================================================================================
     * =============================        CONTEXT        ============================
     * ================================================================================
     * ================================================================================
     */

    /// The list of defined frames
    let dmut _definedFrame = HashSet!{[c8]}::new ();

    // The var decl stack of each block
    let dmut _stackVarDeclChain = Vec!{dmut &TreeChain}::new ();

    // The stack of blocks
    let dmut _stackBlockChain = Vec!{dmut &BlockChain}::new ();

    // The function being generated
    let mut _currentFunctionContext : tree_t = null;

    // List in which all expression to perform at the beginning of the frame are inserted
    let dmut _rootExprList = TreeStatementList::new ();

    // The declaration of the variable in the current function context id => (isRef, varDeclTree)
    let dmut _varDecls = Vec!{dmut &HashMap!{usize, (bool, tree_t)}}::new ();

    // The location of the block opening / closing
    let dmut _blockLocs = Vec!{&Word}::new ();

    // The labels closing loops
    let dmut _loopLabels = Vec!{dmut &Vec!{tree_t}}::new ();

    // The vars for loop values
    let dmut _loopVars = Vec!{dmut &Vec!{tree_t}}::new ();

    /**
     * ================================================================================
     * ================================================================================
     * =========================        SUB GENERATORS        =========================
     * ================================================================================
     * ================================================================================
     */

    // The visitor used to generate types
    let dmut _typeGenerator = GenerateTypeVisitor::new ();

    // The visitor used to generate values
    let dmut _valueGenerator = GenerateValueVisitor::new ();

    // The visitor used to generate operators (sub generation of values)
    let dmut _opGenerator = GenerateOperatorVisitor::new ();

    // The string mangler
    let dmut _mangler = Mangler::new ();

    /**
     * ================================================================================
     * ================================================================================
     * ==============================        CTORS        =============================
     * ================================================================================
     * ================================================================================
     */


    /**
     * Create a new empty generator
     */
    pub self () {}


    /**
     * Generate the GCC trees from gen
     * @params:
     *    - gen: the generator to transform
     */
    pub fn generate (mut self, gen : &Generator) {
        match gen {
            frame : &FrameGenerator => {
                self:.generateFrame (frame);
            }
            cl : &ClassRefType => {
                self._typeGenerator:.generateVtable (alias self, cl);
            }
            _ => {
                eprintln (gen::typeinfo.name);
                eprintln (format ("%", gen));
                __pragma!panic ();
            }
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================         FRAMES         =========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Generate a frame from a frame generator.
     * @params:
     *    - frame: the frame to generate
     * */
    fn generateFrame (mut self, frame : &FrameGenerator) {
        let fnDecl = self:.generateFunctionDecl (frame);
        let asmName = decl::getAsmName (fnDecl);
        if (!state::instance ().isUnittestActive () && frame.getName ().file () == Keys::MAIN) {
            if (!frame.isWeak () || asmName in self._definedFrame) {
                self:.generateMainCall (frame.getLoc (), frame.getReturnType ().isOf!{&VoidType} (), asmName);
            }
        }

        self:.setCurrentFunctionContext (fnDecl);
        self:.enterFrame ();

        let args = self:.generateFrameArguments (frame);
        let resDecl = decl::buildResultDecl (frame.getLoc (), self:.generateType (frame.getReturnType ()));
        decl::setDeclArguments (fnDecl, args);
        c_binding_set_result_decl (fnDecl, resDecl);

        let bodyLoc = frame.getBody ().getLoc ();
        self:.enterBlock (bodyLoc);

        let dmut list = TreeStatementList::new ();
        {
            self._rootExprList = TreeStatementList::new ();
            let bodyLst = self:.generateValue (frame.getBody ());
            if (frame.needFinalReturn ()) {
                list:.append (self._rootExprList.getTree ());
                list:.append (c_binding_get_list_operand (bodyLst))
                    :.append (expr::returnExprTree (bodyLoc,
                                                    resDecl,
                                                    c_binding_get_value_operand (bodyLst)));

            } else {
                list:.append (self._rootExprList.getTree ());
                list:.append (bodyLst);
            }
        }

        let (bind, body) = self:.quitBlock (bodyLoc, list.getTree ());

        c_binding_set_block_super_context (body, fnDecl);
        c_binding_set_decl_initial (fnDecl, body);
        c_binding_set_decl_saved_tree (fnDecl, bind);
        c_binding_set_external (fnDecl, false);
        c_binding_set_preserved (fnDecl, true);
        c_binding_set_public (fnDecl, true);
        c_binding_set_static (fnDecl, true);
        c_binding_set_weak (fnDecl, frame.isWeak ());

        self:.quitFrame ();
        self:.setCurrentFunctionContext (null);
        self._definedFrame:.insert (asmName);

        c_binding_gimplify_function (fnDecl);
        c_binding_finalize_function (fnDecl);
    }

    /**
     * Generate a function declaration from a frame generator
     * */
    fn generateFunctionDecl (mut self, frame : &FrameGenerator)-> tree_t {
        let params = frame.getParameters ();
        let mut args : [mut tree_t] = [cast!{tree_t} (null) ; new params.len];
        for i, p in params {
            args [i] = self:.generateType (p.getType ());
        }

        let ret = self:.generateType (frame.getReturnType ());
        let fnType = types::functionTypeTree (ret, args);
        let fnDecl = decl::functionDeclTree (EOF_WORD, frame.getName ().toStr (sep-> "_"s8), fnType);
        decl::setAsmName (fnDecl, self._mangler.mangleFrame (frame));

        return fnDecl;
    }

    /**
     * Generate the parameter variables of a frame
     * @assume: a function context is entered
     * @params:
     *     - frame: the frame being generated
     * @returns: the list of tree containing the parameters
     * */
    fn generateFrameArguments (mut self, frame : &FrameGenerator)-> [tree_t] {
        let dmut results = Vec!{tree_t}::new ();
        results:.reserve (frame.getParameters ().len);
        for p in frame.getParameters () match p {
            param : &ProtoVarValue => {
                let type = if (param.isReference ()) {
                    pointerTypeTree (self:.generateType (param.getType ()))
                } else { self:.generateType (param.getType ()) };

                let var = decl::paramDeclTree (param.getLoc (), param.getLoc ().str (), type);

                self:.insertVariable (param.getUniqId (), var, param.isReference ());
                c_binding_set_decl_context (var, self.getCurrentFunctionContext ());
                c_binding_set_arg_type (var, type);
                c_binding_set_used (var, true);

                results:.push (var);
            }
            _ => __pragma!panic ();
        }

        results[]
    }

    /**
     * Generate the function calling the main of the program
     * @params:
     *     - loc: the location of the definition of the main function
     *     - mainName: the name of the main function in the program
     *     - isVoid: if true, the main is defined as void
     * */
    fn generateMainCall (mut self, loc :  &Word, isVoid : bool, mainName : [c8]) {
        let argcT = intTypeTree (32, true);
        let argvT = pointerTypeTree (pointerTypeTree (charTypeTree (8)));
        let retT  = intTypeTree (32, true);

        let fnType = types::functionTypeTree (retT, [argcT, argvT]);
        let fnDecl = decl::functionDeclTree (EOF_WORD, Keys::MAIN, fnType);
        decl::setAsmName (fnType, Keys::MAIN);

        self:.setCurrentFunctionContext (fnDecl);
        self:.enterFrame ();

        let argcV = self:.generateParamVar ("argc"s8, argcT);
        let argvV = self:.generateParamVar ("argv"s8, argvT);

        let resDecl = decl::buildResultDecl (EOF_WORD, retT);
        decl::setDeclArguments (fnDecl, [argcV, argvV]);
        c_binding_set_result_decl (fnDecl, resDecl);

        self:.enterBlock (loc);

        let dmut list = TreeStatementList::new ();
        {
            let mainRetT = if (isVoid) {
                types::voidTypeTree ()
            } else {
                retT
            };

            let mainFuncPtr = funcPtrExprTree (loc, mainName, mainRetT, [argcT, argcV]);
            let runMainName = if (state::instance ().isDebugActive ()) {
                CoreNames::RUN_MAIN_DEBUG
            } else {
                CoreNames::RUN_MAIN_RELEASE
            };

            let call = expr::callExprTree (EOF_WORD, mainRetT, runMainName, [argcV, argvV, mainFuncPtr]);
            if (isVoid) {
                list:.append (call)
                    :.append (expr::returnExprTree (EOF_WORD, resDecl, expr::buildIntCst (retT, 0u64)));
            } else {
                list:.append (expr::returnExprTree (EOF_WORD, resDecl, call));
            }
        }

        let (bind, body) = self:.quitBlock (loc, list.getTree ());
        c_binding_set_block_super_context (body, fnDecl);
        c_binding_set_decl_initial (fnDecl, body);
        c_binding_set_decl_saved_tree (fnDecl, bind);
        c_binding_set_external (fnDecl, false);
        c_binding_set_preserved (fnDecl, true);
        c_binding_set_public (fnDecl, true);
        c_binding_set_static (fnDecl, true);

        self:.quitFrame ();
        self:.setCurrentFunctionContext (null);

        c_binding_gimplify_function (fnDecl);
        c_binding_finalize_function (fnDecl);
    }

    /**
     * Generate the GCC tree of a function parameter
     * @params:
     *     - name: the name of the parameter
     *     - type: the tree of the type of the variable to declare
     *  @warning: a function context must be entered
     * */
    fn generateParamVar (mut self, name : [c8], type : tree_t)-> tree_t {
        let var = decl::paramDeclTree (EOF_WORD, name, type);

        c_binding_set_decl_context (var, self.getCurrentFunctionContext ());
        c_binding_set_arg_type (var, type);
        c_binding_set_used (var, true);

        var
    }

    /**
     * ================================================================================
     * ================================================================================
     * ===============================         GETTERS         ========================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: the visitor used to generate types
     * */
    pub fn getTypeVisitor (mut self)-> dmut &GenerateTypeVisitor {
        alias self._typeGenerator
    }

    /**
     * @returns: the visitor used to generate values
     * */
    pub fn getValueVisitor (mut self)-> dmut &GenerateValueVisitor {
        alias self._valueGenerator
    }

    /**
     * @returns: the visitor used to generate operator values
     * */
    pub fn getOperatorVisitor (mut self)-> dmut &GenerateOperatorVisitor {
        alias self._opGenerator
    }

    /**
     * @returns: the mangler for mangling names
     * */
    pub fn getMangler (mut self)-> dmut &Mangler {
        alias self._mangler
    }

    /**
     * =========================================================================
     * =========================================================================
     * ========================           TYPES           ======================
     * =========================================================================
     * =========================================================================
     * */

    /**
     * Generate a type tree from a Type
     * */
    pub fn generateType (mut self, type : &Type)-> tree_t {
        self._typeGenerator:.generate (alias self, type)
    }

    /**
     * =========================================================================
     * =========================================================================
     * ========================           VALUES           =====================
     * =========================================================================
     * =========================================================================
     * */

    /**
     * Generate a value tree from a Value generator
     * */
    pub fn generateValue (mut self, value : &Value)-> tree_t {
        self._valueGenerator.generate (alias self, value)
    }

    /**
     * =========================================================================
     * =========================================================================
     * ======================           MANAGEMENT           ===================
     * =========================================================================
     * =========================================================================
     * */

    /**
     * Set the context of the generation
     * @params:
     *     - fnDecl: the function being generated
     * */
    pub fn setCurrentFunctionContext (mut self, fnDecl : tree_t) {
        self._currentFunctionContext = fnDecl;
    }

    /**
     * @returns: the GCC tree of the function being currently generated
     * */
    pub fn getCurrentFunctionContext (self)-> tree_t {
        self._currentFunctionContext
    }

    /**
     * Enter a new frame generation
     * */
    pub fn enterFrame (mut self) {
        self._varDecls:.push (HashMap!{usize, (bool, tree_t)}::new ());
        self._loopVars:.push (Vec!{tree_t}::new ());
        self._loopLabels:.push (Vec!{tree_t}::new ());
    }

    /**
     * Quit the frame being validated
     * */
    pub fn quitFrame (mut self) {
        __pragma!trusted ({
            self._varDecls:.pop ();
            self._loopLabels:.pop ();
            self._loopVars:.pop ();
        });
    }

    /**
     * Enter a block
     * */
    pub fn enterBlock (mut self, loc : &Word) {
        self._stackBlockChain:.push (BlockChain::new ());
        self._stackVarDeclChain:.push (TreeChain::new ());
        self._blockLocs:.push (loc);
    }

    /**
     * Quit a block
     * @params:
     *     - loc: the location of the block
     *     - content: the list of expression to put inside the block to quit
     * */
    pub fn quitBlock (mut self, loc : &Word, content : tree_t)-> (tree_t, tree_t) {
        let blkLoc = self._blockLocs [$ - 1us];
        if (blkLoc != loc) __pragma!panic ();

        let varChain = self._stackVarDeclChain[$ - 1us];
        let dmut blkChain = (alias self._stackBlockChain)[$ - 1us];

        self._stackBlockChain:.pop ();
        self._stackVarDeclChain:.pop ();
        self._blockLocs:.pop ();

        let block = expr::blockTree (loc, varChain.getTree (), blkChain.getTree ());
        let bind = expr::bindTree (loc, varChain.getTree (), content, block);

        blkChain:.setSuperContext (block);

        (bind, block)
    } catch {
        _ => __pragma!panic ();
    }

    /**
     * Enter a loop context
     * @params:
     *    - lab: the label closing the loop
     *    - var: the variable in which the value of the loop will be written (i.e. for breaks)
     * */
    pub fn enterLoop (mut self, lab : tree_t, var : tree_t) {
        ((alias self._loopLabels) [$ - 1us]):.push (lab);
        ((alias self._loopVars) [$ - 1us]):.push (var);
    }

    /**
     * Quit a loop context
     * */
    pub fn quitLoop (mut self) {
        ((alias self._loopLabels) [$ - 1us]):.pop ();
        ((alias self._loopVars) [$ - 1us]):.pop ();
    } catch {
        _ => __pragma!panic ();
    }

    /**
     * @returns: the current loop variable
     * */
    pub fn getCurrentLoopVar (mut self)-> tree_t {
        ((alias self._loopVars) [$ - 1us])[$ - 1us]
    }

    /**
     * @returns: the current loop closing label
     * */
    pub fn getCurrentLoopLabel (mut self)-> tree_t {
        ((alias self._loopLabels) [$ - 1us]) [$ - 1us]
    }

    /**
     * @returns: the stack var decl chain of the current block
     * */
    pub fn getStackVarDeclChain (mut self)-> dmut &TreeChain {
        return (alias self._stackVarDeclChain)[$ - 1us];
    }

    /**
     * @returns: the block chain of the current block
     * */
    pub fn getBlockChain (mut self)-> dmut &BlockChain {
        return (alias self._stackBlockChain)[$ - 1us];
    }

    /**
     * @returns: the tree stmt list in which expression to run at the entry in the frame before everything else  have to be placed
     * */
    pub fn getRootExprList (mut self)-> dmut &TreeStatementList {
        alias self._rootExprList
    }

    /**
     * @returns: the root stack decl of variable accessible anywhere in the frame
     * */
    pub fn getRootStackVarDeclChain (mut self)-> dmut &TreeChain {
        return (alias self._stackVarDeclChain) [0us]
    }

    /**
     * Insert a variable declaration
     * */
    pub fn insertVariable (mut self, id : usize, var : tree_t, isRef : bool) {
        ((alias self._varDecls)[$ - 1us]):.insert (id, (isRef, var));
    }

    /**
     * Get a variable by its reference id
     * @returns:
     *    - .0: true iif the variable is a reference
     *    - .1: the variable declaration
     * */
    pub fn getVariable (mut self, id : usize)-> (bool, tree_t)? {
        (self._varDecls[$ - 1us]).find (id)
    }


}
