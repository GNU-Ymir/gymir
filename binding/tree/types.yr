mod binding::tree::types;

import binding::tree::c_tree;

/**
 * @returns: the error tree
 */
pub fn errorTree ()-> tree_t {
    return c_binding_error_tree ();
}

/**
 * @returns: the empty tree
 */
pub fn emptyTree () -> tree_t { null }

/**
 * @params:
 *     - vars: the list of variable declared in the block
 *     - chain: the list of instruction inside the block
 * @returns: a block tree
 */
pub fn blockTree (vars : tree_t, chain : tree_t)-> tree_t {
    c_binding_build_block (
        vars, chain, null, null
    )
}

/**
 * @returns: the void type tree
 */
pub def voidTypeTree = c_binding_get_void_type;

/**
 * @returns: the bool type tree
 */
pub def boolTypeTree = c_binding_get_bool_type;

/**
 * @returns: the tree for the int type of the size 'size'
 * */
pub def intTypeTree = c_binding_get_int_type;

/**
 * @returns: the tree for the type usize
 */
pub fn sizeTypeTree ()-> tree_t {
    intTypeTree (0, false)
}

/**
 * @returns: the tree for the type float of size 'size'
 */
pub def floatTypeTree = c_binding_get_float_type;

/**
 * @returns: the tree fo the type char of size 'size'
 */
pub def charTypeTree = c_binding_get_char_type;

/**
 * @returns: the tree for an array type of inner type 'inner' and size 'size'
 */
pub def arrayTypeTree = c_binding_build_array_type;

/**
 * @returns: the tree for a pointer type of inner type 'inner'
 * */
pub def pointerTypeTree = c_binding_build_pointer_type;


/**
 * @params:
 *    - name: the name of the tuple type
 *    - fields: the type of the fields of the tuple
 *    - fieldNames: the name of the fields of the tuple (can be smaller than fields, in that case ._0, ._1, etc. are added)
 *    - isUnion: true if the tuple is an union type
 *    - isPacked: true if the tuple is packed in memory
 * @returns: a tuple type tree
 */
pub fn tupleTypeTree (name : [c8], fields : [tree_t], fieldNames : [[c8]], isUnion : bool = false, isPacked : bool = false)-> tree_t {
    import std::conv;

    let mut fieldStringZ : [mut &c8] = [cast!{&c8} (null) ; new fieldNames.len];
    for i, f in fieldNames {
        fieldStringZ [i] = f.toStringZ ();
    }

    return c_binding_build_tuple_type (name.toStringZ (),
                                       cast!u64 (fields.len), fields.ptr,
                                       cast!u64 (fieldStringZ.len), fieldStringZ.ptr,
                                       isUnion, isPacked);
}

/**
 * @params:
 *     - retType: the return type of the function
 *     - params: the types of the parameters of the function
 * @returns: a function type tree
 */
pub fn functionTypeTree (retType : tree_t, params : [tree_t])-> tree_t {
    return c_binding_build_function_type (retType,
                                          cast!u64 (params.len), params.ptr);
}
