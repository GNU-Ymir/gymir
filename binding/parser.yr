mod binding::parser;

import ymirc::parser;
import ymirc::utils::_;
import ymirc::args::_;
import ymirc::errors::_;
import ymirc::global::state;

import std::collection::vec;

import std::conv;
import std::io;

import binding::version;
import binding::generator::visitor;

extern (C) fn _yrt_exc_init ();
extern (C) fn _yrt_force_debug (f : i32);
extern (C) fn c_binding_fatal_error ();

extern (C) fn ymir_binding_init () {
    _yrt_exc_init ();

    __version DEBUG {
        _yrt_force_debug (1);
    }
}

extern (C) fn ymir_binding_parse_file (nb_files : u32, filenames : &(&c8)) {
    let dmut files = Vec!{[c32]}::new ();
    for i in 0u32 .. nb_files {
        files:.push (filenames [i].fromStringZ ().to![c32] ());
    } catch {
        _ => __pragma!panic ();
    }

    let args = YmirArguments (files-> files[]);
    let gens = {
        let dmut parser = Parser::new (args);
        parser:.parseAll ()
    } catch {
        err : &ErrorMsg => {
            println (format ("%", err));
            __version DEBUG {
                for j in err.getRecursiveTrace () {
                    println (j);
                }
            }

            c_binding_fatal_error ();
            return {}
        }
    }

    let dmut generator = GenerateVisitor::new ();
    for g in gens {
        generator:.generate (g);
    }
}

extern (C) fn ymir_binding_d_add_builtin_version (version : &c8) {
    match version.fromStringZ ()? {
        Ok (v : _) => {
            for d_v in D_VERSIONS::__members__ {
                if d_v._0 == v {
                    state::instance ().addVersion (d_v._1);
                    return {}
                }
            }
        }
    }
}

extern (C) fn ymir_binding_set_size_type (size : u32) {
    state::instance ().setSizeTypeSize (size);
}

extern (C) fn ymir_binding_set_float_size_type (size : u32) {
    state::instance ().setFloatTypeSize (size);
}
